package executor

import (
	"log/slog"
	"os"
	"strings"
	"testing"

	"github.com/randalmurphal/orc/internal/config"
	"github.com/randalmurphal/orc/internal/initiative"
)

func TestInitiativeCompleter_buildInitiativePRBody(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))
	completer := &InitiativeCompleter{logger: logger}

	tests := []struct {
		name       string
		initiative *initiative.Initiative
		contains   []string
		notContain []string
	}{
		{
			name: "basic initiative",
			initiative: &initiative.Initiative{
				ID:    "INIT-001",
				Title: "User Authentication",
			},
			contains: []string{
				"## Initiative: User Authentication",
				"Generated by [orc]",
			},
			notContain: []string{
				"### Vision",
				"### Tasks Completed",
				"### Decisions Made",
			},
		},
		{
			name: "initiative with vision",
			initiative: &initiative.Initiative{
				ID:     "INIT-001",
				Title:  "User Authentication",
				Vision: "Implement secure, scalable auth system",
			},
			contains: []string{
				"## Initiative: User Authentication",
				"### Vision",
				"Implement secure, scalable auth system",
			},
		},
		{
			name: "initiative with tasks",
			initiative: &initiative.Initiative{
				ID:    "INIT-001",
				Title: "User Authentication",
				Tasks: []initiative.TaskRef{
					{ID: "TASK-001", Title: "Login page", Status: "completed"},
					{ID: "TASK-002", Title: "Password reset", Status: "finished"},
					{ID: "TASK-003", Title: "Session mgmt", Status: "in_progress"},
				},
			},
			contains: []string{
				"### Tasks Completed",
				"✅ TASK-001: Login page",
				"✅ TASK-002: Password reset",
				"in_progress TASK-003: Session mgmt",
			},
		},
		{
			name: "initiative with decisions",
			initiative: &initiative.Initiative{
				ID:    "INIT-001",
				Title: "User Authentication",
				Decisions: []initiative.Decision{
					{
						ID:        "DEC-001",
						Decision:  "Use JWT for tokens",
						Rationale: "Stateless, scalable",
					},
					{
						ID:       "DEC-002",
						Decision: "bcrypt for passwords",
					},
				},
			},
			contains: []string{
				"### Decisions Made",
				"**DEC-001**: Use JWT for tokens",
				"Rationale: Stateless, scalable",
				"**DEC-002**: bcrypt for passwords",
			},
		},
		{
			name: "full initiative",
			initiative: &initiative.Initiative{
				ID:     "INIT-001",
				Title:  "User Authentication",
				Vision: "Secure auth for all users",
				Tasks: []initiative.TaskRef{
					{ID: "TASK-001", Title: "Login", Status: "completed"},
				},
				Decisions: []initiative.Decision{
					{ID: "DEC-001", Decision: "Use OAuth2"},
				},
			},
			contains: []string{
				"## Initiative: User Authentication",
				"### Vision",
				"### Tasks Completed",
				"### Decisions Made",
				"Generated by [orc]",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			body := completer.buildInitiativePRBody(tt.initiative)

			for _, want := range tt.contains {
				if !strings.Contains(body, want) {
					t.Errorf("body should contain %q, got:\n%s", want, body)
				}
			}

			for _, notWant := range tt.notContain {
				if strings.Contains(body, notWant) {
					t.Errorf("body should NOT contain %q, got:\n%s", notWant, body)
				}
			}
		})
	}
}

func TestInitiativeCompleter_getProfile(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))

	tests := []struct {
		name     string
		cfg      *config.Config
		expected config.AutomationProfile
	}{
		{
			name:     "nil config defaults to auto",
			cfg:      nil,
			expected: config.ProfileAuto,
		},
		{
			name:     "empty profile defaults to auto",
			cfg:      &config.Config{},
			expected: config.ProfileAuto,
		},
		{
			name: "explicit auto profile",
			cfg: &config.Config{
				Profile: config.ProfileAuto,
			},
			expected: config.ProfileAuto,
		},
		{
			name: "fast profile",
			cfg: &config.Config{
				Profile: config.ProfileFast,
			},
			expected: config.ProfileFast,
		},
		{
			name: "safe profile",
			cfg: &config.Config{
				Profile: config.ProfileSafe,
			},
			expected: config.ProfileSafe,
		},
		{
			name: "strict profile",
			cfg: &config.Config{
				Profile: config.ProfileStrict,
			},
			expected: config.ProfileStrict,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			completer := &InitiativeCompleter{
				cfg:    tt.cfg,
				logger: logger,
			}
			got := completer.getProfile()
			if got != tt.expected {
				t.Errorf("getProfile() = %q, want %q", got, tt.expected)
			}
		})
	}
}

func TestInitiativeCompleter_getTargetBranch(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))

	tests := []struct {
		name     string
		cfg      *config.Config
		expected string
	}{
		{
			name:     "nil config defaults to main",
			cfg:      nil,
			expected: "main",
		},
		{
			name:     "empty target defaults to main",
			cfg:      &config.Config{},
			expected: "main",
		},
		{
			name: "configured target branch",
			cfg: &config.Config{
				Completion: config.CompletionConfig{
					TargetBranch: "develop",
				},
			},
			expected: "develop",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			completer := &InitiativeCompleter{
				cfg:    tt.cfg,
				logger: logger,
			}
			got := completer.getTargetBranch()
			if got != tt.expected {
				t.Errorf("getTargetBranch() = %q, want %q", got, tt.expected)
			}
		})
	}
}

func TestInitiativeCompleter_getPRLabels(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))

	tests := []struct {
		name     string
		cfg      *config.Config
		expected []string
	}{
		{
			name:     "nil config defaults to initiative label",
			cfg:      nil,
			expected: []string{"initiative"},
		},
		{
			name:     "empty labels defaults to initiative label",
			cfg:      &config.Config{},
			expected: []string{"initiative"},
		},
		{
			name: "configured labels",
			cfg: &config.Config{
				Completion: config.CompletionConfig{
					PR: config.PRConfig{
						Labels: []string{"orc", "automated"},
					},
				},
			},
			expected: []string{"orc", "automated"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			completer := &InitiativeCompleter{
				cfg:    tt.cfg,
				logger: logger,
			}
			got := completer.getPRLabels()
			if len(got) != len(tt.expected) {
				t.Errorf("getPRLabels() = %v, want %v", got, tt.expected)
				return
			}
			for i, label := range got {
				if label != tt.expected[i] {
					t.Errorf("getPRLabels()[%d] = %q, want %q", i, label, tt.expected[i])
				}
			}
		})
	}
}

func TestInitiativeCompleter_shouldAutoMerge(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))

	tests := []struct {
		name     string
		profile  config.AutomationProfile
		expected bool
	}{
		{
			name:     "auto profile should auto-merge",
			profile:  config.ProfileAuto,
			expected: true,
		},
		{
			name:     "fast profile should auto-merge",
			profile:  config.ProfileFast,
			expected: true,
		},
		{
			name:     "safe profile should not auto-merge",
			profile:  config.ProfileSafe,
			expected: false,
		},
		{
			name:     "strict profile should not auto-merge",
			profile:  config.ProfileStrict,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			completer := &InitiativeCompleter{
				cfg: &config.Config{
					Profile: tt.profile,
				},
				logger: logger,
			}
			got := completer.shouldAutoMerge()
			if got != tt.expected {
				t.Errorf("shouldAutoMerge() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestNewInitiativeCompleter(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))
	cfg := &config.Config{}

	completer := NewInitiativeCompleter(nil, nil, nil, cfg, logger, "/path/to/project")

	if completer == nil {
		t.Fatal("NewInitiativeCompleter returned nil")
	}
	if completer.cfg != cfg {
		t.Error("config not set correctly")
	}
	if completer.logger != logger {
		t.Error("logger not set correctly")
	}
	if completer.projectDir != "/path/to/project" {
		t.Errorf("projectDir = %q, want %q", completer.projectDir, "/path/to/project")
	}
}

func TestInitiativeCompletionResult(t *testing.T) {
	// Test that result struct properly stores values
	result := &InitiativeCompletionResult{
		InitiativeID: "INIT-001",
		Merged:       true,
		MergeCommit:  "abc123",
		PRURL:        "https://github.com/org/repo/pull/42",
		PRNumber:     42,
	}

	if result.InitiativeID != "INIT-001" {
		t.Errorf("InitiativeID = %q, want %q", result.InitiativeID, "INIT-001")
	}
	if !result.Merged {
		t.Error("Merged should be true")
	}
	if result.MergeCommit != "abc123" {
		t.Errorf("MergeCommit = %q, want %q", result.MergeCommit, "abc123")
	}
	if result.PRURL != "https://github.com/org/repo/pull/42" {
		t.Errorf("PRURL = %q", result.PRURL)
	}
	if result.PRNumber != 42 {
		t.Errorf("PRNumber = %d, want %d", result.PRNumber, 42)
	}
}

