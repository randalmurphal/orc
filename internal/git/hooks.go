// Package git provides git operations for orc, wrapping devflow/git.
package git

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// DefaultProtectedBranches is the list of branches that should never be pushed to directly.
var DefaultProtectedBranches = []string{"main", "master", "develop", "release"}

// HookConfig contains configuration for worktree hook injection.
type HookConfig struct {
	// ProtectedBranches is the list of branches that should be protected from direct pushes.
	// Defaults to DefaultProtectedBranches if empty.
	ProtectedBranches []string

	// TaskBranch is the expected branch name for this worktree.
	TaskBranch string

	// TaskID is the task identifier for logging purposes.
	TaskID string
}

// InjectWorktreeHooks injects safety hooks into a worktree's git directory.
// These hooks prevent pushing to protected branches and validate that commits
// are made on the expected task branch.
//
// Hooks are stored in .git/worktrees/<worktree-name>/hooks/ and configured
// via core.hooksPath in the worktree's local config. This ensures:
// - Hooks are ephemeral (deleted with worktree cleanup)
// - Hooks don't conflict with the main repo's hooks
// - Each task gets isolated enforcement
func (g *Git) InjectWorktreeHooks(worktreePath string, cfg HookConfig) error {
	// Get the worktree's git directory (e.g., .git/worktrees/orc-TASK-001)
	worktreeGitDir, err := g.getWorktreeGitDir(worktreePath)
	if err != nil {
		return fmt.Errorf("get worktree git dir: %w", err)
	}

	hooksDir := filepath.Join(worktreeGitDir, "hooks")
	if err := os.MkdirAll(hooksDir, 0755); err != nil {
		return fmt.Errorf("create hooks dir: %w", err)
	}

	protectedBranches := cfg.ProtectedBranches
	if len(protectedBranches) == 0 {
		protectedBranches = DefaultProtectedBranches
	}

	// Write pre-push hook
	prePushContent := generatePrePushHook(cfg.TaskBranch, cfg.TaskID, protectedBranches)
	if err := writeExecutableFile(filepath.Join(hooksDir, "pre-push"), prePushContent); err != nil {
		return fmt.Errorf("write pre-push hook: %w", err)
	}

	// Write pre-commit hook
	preCommitContent := generatePreCommitHook(cfg.TaskBranch, cfg.TaskID)
	if err := writeExecutableFile(filepath.Join(hooksDir, "pre-commit"), preCommitContent); err != nil {
		return fmt.Errorf("write pre-commit hook: %w", err)
	}

	// Configure worktree to use these hooks by writing directly to worktree config.
	// IMPORTANT: Using `git config --local` writes to the main repo's .git/config,
	// which would incorrectly apply hooks to ALL repositories including main.
	// Instead, we write directly to .git/worktrees/<name>/config to ensure hooks
	// only apply to this specific worktree.
	worktreeConfigPath := filepath.Join(worktreeGitDir, "config")
	configContent := fmt.Sprintf("[core]\n\thooksPath = %s\n", hooksDir)
	if err := os.WriteFile(worktreeConfigPath, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("write worktree config: %w", err)
	}

	return nil
}

// getWorktreeGitDir returns the git directory for a worktree.
// For a worktree at .orc/worktrees/orc-TASK-001, this returns
// .git/worktrees/orc-TASK-001 (the actual git metadata directory).
func (g *Git) getWorktreeGitDir(worktreePath string) (string, error) {
	// Read the .git file in the worktree to find the actual git dir
	gitFile := filepath.Join(worktreePath, ".git")
	content, err := os.ReadFile(gitFile)
	if err != nil {
		return "", fmt.Errorf("read .git file: %w", err)
	}

	// Parse "gitdir: /path/to/.git/worktrees/name"
	line := strings.TrimSpace(string(content))
	if !strings.HasPrefix(line, "gitdir: ") {
		return "", fmt.Errorf("invalid .git file format: %s", line)
	}

	gitDir := strings.TrimPrefix(line, "gitdir: ")
	return gitDir, nil
}

// generatePrePushHook generates a pre-push hook that blocks pushes to protected branches.
// The hook includes worktree detection to prevent false positives when the hook
// is accidentally triggered from the main repository.
func generatePrePushHook(taskBranch, taskID string, protectedBranches []string) string {
	if len(protectedBranches) == 0 {
		protectedBranches = DefaultProtectedBranches
	}
	protected := strings.Join(protectedBranches, " ")

	return fmt.Sprintf(`#!/bin/bash
# Orc worktree safety hook - prevents pushing to protected branches
# Task: %s
# Branch: %s
# Generated by orc - DO NOT EDIT

set -e

PROTECTED_BRANCHES="%s"
TASK_BRANCH="%s"
TASK_ID="%s"

# Detect if we're actually in a worktree by checking the .git entry.
# In a worktree, .git is a file containing "gitdir: /path/to/.git/worktrees/<name>"
# In the main repo, .git is a directory.
GIT_DIR_ENTRY=$(git rev-parse --git-dir 2>/dev/null)

# If we're not in a worktree (git-dir doesn't contain "worktrees"), skip validation.
# This prevents false positives when hooks are accidentally applied to the main repo.
if [[ ! "$GIT_DIR_ENTRY" =~ worktrees/ ]]; then
    exit 0
fi

while read local_ref local_sha remote_ref remote_sha; do
    # Extract the remote branch name
    remote_branch="${remote_ref#refs/heads/}"

    # Check against protected branches
    for protected in $PROTECTED_BRANCHES; do
        if [ "$remote_branch" = "$protected" ]; then
            echo ""
            echo "==============================================="
            echo "  BLOCKED: Push to protected branch '$protected'"
            echo "==============================================="
            echo ""
            echo "  Task: $TASK_ID"
            echo "  Task Branch: $TASK_BRANCH"
            echo ""
            echo "  Direct pushes to protected branches are not allowed."
            echo "  Use the PR workflow instead:"
            echo "    orc run $TASK_ID  # Creates PR automatically"
            echo ""
            exit 1
        fi
    done
done

exit 0
`, taskID, taskBranch, protected, taskBranch, taskID)
}

// generatePreCommitHook generates a pre-commit hook that validates the current branch.
// The hook includes worktree detection to prevent false positives when the hook
// is accidentally triggered from the main repository.
func generatePreCommitHook(taskBranch, taskID string) string {
	return fmt.Sprintf(`#!/bin/bash
# Orc worktree safety hook - validates commits are on expected branch
# Task: %s
# Branch: %s
# Generated by orc - DO NOT EDIT

set -e

EXPECTED_BRANCH="%s"
TASK_ID="%s"

# Detect if we're actually in a worktree by checking the .git entry.
# In a worktree, .git is a file containing "gitdir: /path/to/.git/worktrees/<name>"
# In the main repo, .git is a directory.
GIT_DIR_ENTRY=$(git rev-parse --git-dir 2>/dev/null)

# If we're not in a worktree (git-dir doesn't contain "worktrees"), skip validation.
# This prevents false positives when hooks are accidentally applied to the main repo.
if [[ ! "$GIT_DIR_ENTRY" =~ worktrees/ ]]; then
    exit 0
fi

CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

if [ "$CURRENT_BRANCH" != "$EXPECTED_BRANCH" ]; then
    echo ""
    echo "==============================================="
    echo "  WARNING: Unexpected branch for task"
    echo "==============================================="
    echo ""
    echo "  Task: $TASK_ID"
    echo "  Expected branch: $EXPECTED_BRANCH"
    echo "  Current branch: $CURRENT_BRANCH"
    echo ""
    echo "  This worktree is configured for a specific task."
    echo "  Commits should be made on the task branch."
    echo ""
    # Allow the commit but warn - user might have legitimate reason
    # The pre-push hook will still block pushes to protected branches
fi

exit 0
`, taskID, taskBranch, taskBranch, taskID)
}

// writeExecutableFile writes content to a file and makes it executable.
func writeExecutableFile(path, content string) error {
	return os.WriteFile(path, []byte(content), 0755)
}

// IsProtectedBranch checks if a branch name is in the protected list.
func IsProtectedBranch(branch string, protectedBranches []string) bool {
	if len(protectedBranches) == 0 {
		protectedBranches = DefaultProtectedBranches
	}
	for _, p := range protectedBranches {
		if branch == p {
			return true
		}
	}
	return false
}

// RemoveWorktreeHooks removes the injected hooks from a worktree.
// This is called during worktree cleanup.
func (g *Git) RemoveWorktreeHooks(worktreePath string) error {
	worktreeGitDir, err := g.getWorktreeGitDir(worktreePath)
	if err != nil {
		// Worktree might already be partially cleaned up - log but don't fail
		fmt.Fprintf(os.Stderr, "warning: could not get worktree git dir for hook cleanup: %v\n", err)
		return nil
	}

	hooksDir := filepath.Join(worktreeGitDir, "hooks")
	if err := os.RemoveAll(hooksDir); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("remove hooks dir: %w", err)
	}

	return nil
}

// ClaudeCodeHookConfig contains configuration for Claude Code hook injection.
type ClaudeCodeHookConfig struct {
	// WorktreePath is the absolute path to the worktree.
	WorktreePath string

	// MainRepoPath is the absolute path to the main repository (to block access to it).
	MainRepoPath string

	// TaskID is the task identifier for logging purposes.
	TaskID string
}

// InjectClaudeCodeHooks injects Claude Code PreToolUse hooks into the worktree.
// These hooks intercept file operations (Edit, Write, Read, Glob, Grep) and block
// any attempts to access files outside the worktree directory.
//
// The hooks are stored in the worktree's .claude directory:
// - .claude/settings.json - Hook configuration
// - .claude/hooks/worktree-isolation.py - The validation script
//
// This prevents Claude from accidentally modifying the main repository when
// running in an isolated worktree context.
func InjectClaudeCodeHooks(cfg ClaudeCodeHookConfig) error {
	// Create .claude directory in worktree
	claudeDir := filepath.Join(cfg.WorktreePath, ".claude")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		return fmt.Errorf("create .claude dir: %w", err)
	}

	// Create hooks subdirectory
	hooksDir := filepath.Join(claudeDir, "hooks")
	if err := os.MkdirAll(hooksDir, 0755); err != nil {
		return fmt.Errorf("create hooks dir: %w", err)
	}

	// Write the isolation hook script
	hookScript := generateWorktreeIsolationHook()
	hookPath := filepath.Join(hooksDir, "worktree-isolation.py")
	if err := writeExecutableFile(hookPath, hookScript); err != nil {
		return fmt.Errorf("write isolation hook: %w", err)
	}

	// Write settings.json with hook configuration
	settingsContent := generateClaudeCodeSettings(hookPath, cfg)
	settingsPath := filepath.Join(claudeDir, "settings.json")
	if err := os.WriteFile(settingsPath, []byte(settingsContent), 0644); err != nil {
		return fmt.Errorf("write settings.json: %w", err)
	}

	return nil
}

// generateClaudeCodeSettings generates the .claude/settings.json content
// with PreToolUse hooks for worktree isolation and TDD discipline.
func generateClaudeCodeSettings(hookPath string, cfg ClaudeCodeHookConfig) string {
	// Escape paths for JSON
	escapedHookPath := strings.ReplaceAll(hookPath, `\`, `\\`)
	escapedHookPath = strings.ReplaceAll(escapedHookPath, `"`, `\"`)

	escapedWorktree := strings.ReplaceAll(cfg.WorktreePath, `\`, `\\`)
	escapedWorktree = strings.ReplaceAll(escapedWorktree, `"`, `\"`)

	escapedMainRepo := strings.ReplaceAll(cfg.MainRepoPath, `\`, `\\`)
	escapedMainRepo = strings.ReplaceAll(escapedMainRepo, `"`, `\"`)

	// TDD discipline hook path (installed by bootstrap to project's .claude/hooks/)
	tddHookPath := filepath.Join(cfg.MainRepoPath, ".claude", "hooks", "tdd-discipline.sh")
	escapedTddHook := strings.ReplaceAll(tddHookPath, `\`, `\\`)
	escapedTddHook = strings.ReplaceAll(escapedTddHook, `"`, `\"`)

	return fmt.Sprintf(`{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit|Write|Read|Glob|Grep|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "ORC_WORKTREE_PATH=\"%s\" ORC_MAIN_REPO_PATH=\"%s\" python3 \"%s\""
          }
        ]
      },
      {
        "matcher": "Edit|Write|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "bash \"%s\""
          }
        ]
      }
    ]
  }
}
`, escapedWorktree, escapedMainRepo, escapedHookPath, escapedTddHook)
}

// generateWorktreeIsolationHook returns the Python script content for the
// worktree isolation PreToolUse hook.
func generateWorktreeIsolationHook() string {
	return `#!/usr/bin/env python3
"""
Worktree Isolation Hook for Claude Code

This PreToolUse hook enforces that file operations stay within the worktree directory.
It blocks Edit, Write, Read, Glob, and Grep operations that target paths outside the
worktree, preventing accidental modification of the main repository.

Exit codes:
- 0: Allow tool execution
- 2: Block tool execution (stderr message shown to user)
"""

import json
import os
import sys


def get_worktree_path():
    """Get the worktree path from environment or CWD."""
    worktree_path = os.environ.get("ORC_WORKTREE_PATH")
    if worktree_path:
        return os.path.realpath(worktree_path)
    return os.path.realpath(os.getcwd())


def get_main_repo_path():
    """Get the main repository path (to explicitly block it)."""
    return os.environ.get("ORC_MAIN_REPO_PATH", "")


def normalize_path(path, worktree_path):
    """Normalize a path to an absolute path."""
    if not path:
        return None
    if not os.path.isabs(path):
        return os.path.realpath(os.path.join(worktree_path, path))
    return os.path.realpath(path)


def is_path_in_worktree(path, worktree_path):
    """Check if a path is within the worktree directory."""
    if not path:
        return True
    normalized = normalize_path(path, worktree_path)
    if not normalized:
        return True
    return normalized.startswith(worktree_path + os.sep) or normalized == worktree_path


def is_path_in_main_repo(path, worktree_path, main_repo_path):
    """Check if a path is within the main repository."""
    if not path or not main_repo_path:
        return False
    normalized = normalize_path(path, worktree_path)
    if not normalized:
        return False
    return normalized.startswith(main_repo_path + os.sep) or normalized == main_repo_path


def extract_paths_from_input(tool_name, tool_input):
    """Extract file paths from tool input based on tool type."""
    paths = []
    if tool_name in ("Edit", "Write", "Read"):
        path = tool_input.get("file_path")
        if path:
            paths.append(path)
    elif tool_name == "Glob":
        path = tool_input.get("path")
        if path:
            paths.append(path)
        pattern = tool_input.get("pattern", "")
        if pattern.startswith("/"):
            paths.append(pattern)
    elif tool_name == "Grep":
        path = tool_input.get("path")
        if path:
            paths.append(path)
    elif tool_name == "MultiEdit":
        for edit in tool_input.get("edits", []):
            path = edit.get("file_path")
            if path:
                paths.append(path)
    return paths


def main():
    try:
        input_data = json.loads(sys.stdin.read())
    except json.JSONDecodeError:
        sys.exit(0)

    tool_name = input_data.get("tool_name", "")
    tool_input = input_data.get("tool_input", {})

    file_tools = {"Edit", "Write", "Read", "Glob", "Grep", "MultiEdit"}
    if tool_name not in file_tools:
        sys.exit(0)

    worktree_path = get_worktree_path()
    main_repo_path = get_main_repo_path()
    paths = extract_paths_from_input(tool_name, tool_input)

    for path in paths:
        # IMPORTANT: Check worktree first! The worktree is inside the main repo directory,
        # so we must check if path is in worktree before checking main repo.
        if is_path_in_worktree(path, worktree_path):
            # Path is in worktree - allow it
            continue

        # Path is NOT in worktree - check if it's trying to access main repo
        if main_repo_path and is_path_in_main_repo(path, worktree_path, main_repo_path):
            print(f"""
╔══════════════════════════════════════════════════════════════════════════════╗
║  BLOCKED: File operation targeting main repository                           ║
╠══════════════════════════════════════════════════════════════════════════════╣
║  Tool: {tool_name:<70} ║
║  Path: {path[:70]:<70} ║
║                                                                              ║
║  You are in an ISOLATED WORKTREE. Use relative paths to stay within it.      ║
║  Worktree: {worktree_path[:66]:<66} ║
╚══════════════════════════════════════════════════════════════════════════════╝
""", file=sys.stderr)
            sys.exit(2)

        # Path is outside both worktree and main repo
        print(f"""
╔══════════════════════════════════════════════════════════════════════════════╗
║  BLOCKED: File operation outside worktree                                    ║
╠══════════════════════════════════════════════════════════════════════════════╣
║  Tool: {tool_name:<70} ║
║  Path: {path[:70]:<70} ║
║                                                                              ║
║  You are in an ISOLATED WORKTREE. Use relative paths to stay within it.      ║
║  Worktree: {worktree_path[:66]:<66} ║
╚══════════════════════════════════════════════════════════════════════════════╝
""", file=sys.stderr)
        sys.exit(2)

    sys.exit(0)


if __name__ == "__main__":
    main()
`
}

// RemoveClaudeCodeHooks removes the injected Claude Code hooks from a worktree.
func RemoveClaudeCodeHooks(worktreePath string) error {
	claudeDir := filepath.Join(worktreePath, ".claude")

	// Remove the entire .claude directory
	if err := os.RemoveAll(claudeDir); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("remove .claude dir: %w", err)
	}

	return nil
}

// EnsureClaudeSettingsUntracked marks .claude/settings.json as "assume-unchanged"
// in git, so local modifications don't appear as dirty working tree state.
// This ensures machine-specific worktree hooks don't interfere with git rebase/merge.
//
// This is necessary because:
// 1. Worktree isolation hooks contain machine-specific absolute paths
// 2. These paths differ between machines (Mac vs Linux, different users)
// 3. If git sees the file as modified, rebase fails with "unstaged changes" error
// 4. Using --assume-unchanged tells git to ignore local modifications
//
// The function also adds the file to local git exclude to prevent accidental commits.
// The function is idempotent - safe to call multiple times.
func EnsureClaudeSettingsUntracked(worktreePath string) error {
	settingsRelPath := ".claude/settings.json"

	// Check if file is tracked by git
	cmd := execCommand("git", "ls-files", settingsRelPath)
	cmd.Dir = worktreePath
	output, err := cmd.Output()
	if err != nil {
		// git ls-files failed, might not be a git repo - skip
		return nil
	}

	if strings.TrimSpace(string(output)) != "" {
		// File is tracked - mark as assume-unchanged so git ignores local modifications.
		// This allows rebase/merge to proceed without seeing the file as dirty.
		cmd = execCommand("git", "update-index", "--assume-unchanged", settingsRelPath)
		cmd.Dir = worktreePath
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("mark %s as assume-unchanged: %w", settingsRelPath, err)
		}
	}

	// Add to local git exclude to prevent accidental staging/commits
	return addToGitExclude(worktreePath, settingsRelPath)
}

// addToGitExclude adds a path to the worktree's local git exclude file.
// For worktrees, this is in .git/worktrees/<name>/info/exclude.
func addToGitExclude(worktreePath, pattern string) error {
	// Find the git directory for this worktree
	gitFile := filepath.Join(worktreePath, ".git")
	content, err := os.ReadFile(gitFile)
	if err != nil {
		// Might be a regular repo or .git doesn't exist - try standard path
		return addToExcludeFile(filepath.Join(worktreePath, ".git", "info", "exclude"), pattern)
	}

	// Parse "gitdir: /path/to/.git/worktrees/name"
	line := strings.TrimSpace(string(content))
	if !strings.HasPrefix(line, "gitdir: ") {
		// Not a worktree format, use standard path
		return addToExcludeFile(filepath.Join(worktreePath, ".git", "info", "exclude"), pattern)
	}

	gitDir := strings.TrimPrefix(line, "gitdir: ")
	excludePath := filepath.Join(gitDir, "info", "exclude")
	return addToExcludeFile(excludePath, pattern)
}

// addToExcludeFile adds a pattern to a git exclude file if not already present.
func addToExcludeFile(excludePath, pattern string) error {
	// Ensure the info directory exists
	infoDir := filepath.Dir(excludePath)
	if err := os.MkdirAll(infoDir, 0755); err != nil {
		return fmt.Errorf("create info dir: %w", err)
	}

	// Read existing content
	existingContent, err := os.ReadFile(excludePath)
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("read exclude file: %w", err)
	}

	// Check if pattern already exists
	lines := strings.Split(string(existingContent), "\n")
	for _, line := range lines {
		if strings.TrimSpace(line) == pattern {
			// Already excluded
			return nil
		}
	}

	// Append pattern
	var newContent string
	if len(existingContent) > 0 && !strings.HasSuffix(string(existingContent), "\n") {
		newContent = string(existingContent) + "\n" + pattern + "\n"
	} else {
		newContent = string(existingContent) + pattern + "\n"
	}

	if err := os.WriteFile(excludePath, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("write exclude file: %w", err)
	}

	return nil
}

// execCommand is a variable to allow test mocking of exec.Command.
var execCommand = exec.Command
