// Package git provides git operations for orc, wrapping devflow/git.
package git

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// DefaultProtectedBranches is the list of branches that should never be pushed to directly.
var DefaultProtectedBranches = []string{"main", "master", "develop", "release"}

// HookConfig contains configuration for worktree hook injection.
type HookConfig struct {
	// ProtectedBranches is the list of branches that should be protected from direct pushes.
	// Defaults to DefaultProtectedBranches if empty.
	ProtectedBranches []string

	// TaskBranch is the expected branch name for this worktree.
	TaskBranch string

	// TaskID is the task identifier for logging purposes.
	TaskID string
}

// InjectWorktreeHooks injects safety hooks into a worktree's git directory.
// These hooks prevent pushing to protected branches and validate that commits
// are made on the expected task branch.
//
// Hooks are stored in .git/worktrees/<worktree-name>/hooks/ and configured
// via core.hooksPath in the worktree's local config. This ensures:
// - Hooks are ephemeral (deleted with worktree cleanup)
// - Hooks don't conflict with the main repo's hooks
// - Each task gets isolated enforcement
func (g *Git) InjectWorktreeHooks(worktreePath string, cfg HookConfig) error {
	// Get the worktree's git directory (e.g., .git/worktrees/orc-TASK-001)
	worktreeGitDir, err := g.getWorktreeGitDir(worktreePath)
	if err != nil {
		return fmt.Errorf("get worktree git dir: %w", err)
	}

	hooksDir := filepath.Join(worktreeGitDir, "hooks")
	if err := os.MkdirAll(hooksDir, 0755); err != nil {
		return fmt.Errorf("create hooks dir: %w", err)
	}

	protectedBranches := cfg.ProtectedBranches
	if len(protectedBranches) == 0 {
		protectedBranches = DefaultProtectedBranches
	}

	// Write pre-push hook
	prePushContent := generatePrePushHook(cfg.TaskBranch, cfg.TaskID, protectedBranches)
	if err := writeExecutableFile(filepath.Join(hooksDir, "pre-push"), prePushContent); err != nil {
		return fmt.Errorf("write pre-push hook: %w", err)
	}

	// Write pre-commit hook
	preCommitContent := generatePreCommitHook(cfg.TaskBranch, cfg.TaskID)
	if err := writeExecutableFile(filepath.Join(hooksDir, "pre-commit"), preCommitContent); err != nil {
		return fmt.Errorf("write pre-commit hook: %w", err)
	}

	// Configure worktree to use these hooks by writing directly to worktree config.
	// IMPORTANT: Using `git config --local` writes to the main repo's .git/config,
	// which would incorrectly apply hooks to ALL repositories including main.
	// Instead, we write directly to .git/worktrees/<name>/config to ensure hooks
	// only apply to this specific worktree.
	worktreeConfigPath := filepath.Join(worktreeGitDir, "config")
	configContent := fmt.Sprintf("[core]\n\thooksPath = %s\n", hooksDir)
	if err := os.WriteFile(worktreeConfigPath, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("write worktree config: %w", err)
	}

	return nil
}

// getWorktreeGitDir returns the git directory for a worktree.
// For a worktree at .orc/worktrees/orc-TASK-001, this returns
// .git/worktrees/orc-TASK-001 (the actual git metadata directory).
func (g *Git) getWorktreeGitDir(worktreePath string) (string, error) {
	// Read the .git file in the worktree to find the actual git dir
	gitFile := filepath.Join(worktreePath, ".git")
	content, err := os.ReadFile(gitFile)
	if err != nil {
		return "", fmt.Errorf("read .git file: %w", err)
	}

	// Parse "gitdir: /path/to/.git/worktrees/name"
	line := strings.TrimSpace(string(content))
	if !strings.HasPrefix(line, "gitdir: ") {
		return "", fmt.Errorf("invalid .git file format: %s", line)
	}

	gitDir := strings.TrimPrefix(line, "gitdir: ")
	return gitDir, nil
}

// generatePrePushHook generates a pre-push hook that blocks pushes to protected branches.
// The hook includes worktree detection to prevent false positives when the hook
// is accidentally triggered from the main repository.
func generatePrePushHook(taskBranch, taskID string, protectedBranches []string) string {
	if len(protectedBranches) == 0 {
		protectedBranches = DefaultProtectedBranches
	}
	protected := strings.Join(protectedBranches, " ")

	return fmt.Sprintf(`#!/bin/bash
# Orc worktree safety hook - prevents pushing to protected branches
# Task: %s
# Branch: %s
# Generated by orc - DO NOT EDIT

set -e

PROTECTED_BRANCHES="%s"
TASK_BRANCH="%s"
TASK_ID="%s"

# Detect if we're actually in a worktree by checking the .git entry.
# In a worktree, .git is a file containing "gitdir: /path/to/.git/worktrees/<name>"
# In the main repo, .git is a directory.
GIT_DIR_ENTRY=$(git rev-parse --git-dir 2>/dev/null)

# If we're not in a worktree (git-dir doesn't contain "worktrees"), skip validation.
# This prevents false positives when hooks are accidentally applied to the main repo.
if [[ ! "$GIT_DIR_ENTRY" =~ worktrees/ ]]; then
    exit 0
fi

while read local_ref local_sha remote_ref remote_sha; do
    # Extract the remote branch name
    remote_branch="${remote_ref#refs/heads/}"

    # Check against protected branches
    for protected in $PROTECTED_BRANCHES; do
        if [ "$remote_branch" = "$protected" ]; then
            echo ""
            echo "==============================================="
            echo "  BLOCKED: Push to protected branch '$protected'"
            echo "==============================================="
            echo ""
            echo "  Task: $TASK_ID"
            echo "  Task Branch: $TASK_BRANCH"
            echo ""
            echo "  Direct pushes to protected branches are not allowed."
            echo "  Use the PR workflow instead:"
            echo "    orc run $TASK_ID  # Creates PR automatically"
            echo ""
            exit 1
        fi
    done
done

exit 0
`, taskID, taskBranch, protected, taskBranch, taskID)
}

// generatePreCommitHook generates a pre-commit hook that validates the current branch.
// The hook includes worktree detection to prevent false positives when the hook
// is accidentally triggered from the main repository.
func generatePreCommitHook(taskBranch, taskID string) string {
	return fmt.Sprintf(`#!/bin/bash
# Orc worktree safety hook - validates commits are on expected branch
# Task: %s
# Branch: %s
# Generated by orc - DO NOT EDIT

set -e

EXPECTED_BRANCH="%s"
TASK_ID="%s"

# Detect if we're actually in a worktree by checking the .git entry.
# In a worktree, .git is a file containing "gitdir: /path/to/.git/worktrees/<name>"
# In the main repo, .git is a directory.
GIT_DIR_ENTRY=$(git rev-parse --git-dir 2>/dev/null)

# If we're not in a worktree (git-dir doesn't contain "worktrees"), skip validation.
# This prevents false positives when hooks are accidentally applied to the main repo.
if [[ ! "$GIT_DIR_ENTRY" =~ worktrees/ ]]; then
    exit 0
fi

CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

if [ "$CURRENT_BRANCH" != "$EXPECTED_BRANCH" ]; then
    echo ""
    echo "==============================================="
    echo "  WARNING: Unexpected branch for task"
    echo "==============================================="
    echo ""
    echo "  Task: $TASK_ID"
    echo "  Expected branch: $EXPECTED_BRANCH"
    echo "  Current branch: $CURRENT_BRANCH"
    echo ""
    echo "  This worktree is configured for a specific task."
    echo "  Commits should be made on the task branch."
    echo ""
    # Allow the commit but warn - user might have legitimate reason
    # The pre-push hook will still block pushes to protected branches
fi

exit 0
`, taskID, taskBranch, taskBranch, taskID)
}

// writeExecutableFile writes content to a file and makes it executable.
func writeExecutableFile(path, content string) error {
	return os.WriteFile(path, []byte(content), 0755)
}

// IsProtectedBranch checks if a branch name is in the protected list.
func IsProtectedBranch(branch string, protectedBranches []string) bool {
	if len(protectedBranches) == 0 {
		protectedBranches = DefaultProtectedBranches
	}
	for _, p := range protectedBranches {
		if branch == p {
			return true
		}
	}
	return false
}

// RemoveWorktreeHooks removes the injected hooks from a worktree.
// This is called during worktree cleanup.
func (g *Git) RemoveWorktreeHooks(worktreePath string) error {
	worktreeGitDir, err := g.getWorktreeGitDir(worktreePath)
	if err != nil {
		// Worktree might already be partially cleaned up - log but don't fail
		fmt.Fprintf(os.Stderr, "warning: could not get worktree git dir for hook cleanup: %v\n", err)
		return nil
	}

	hooksDir := filepath.Join(worktreeGitDir, "hooks")
	if err := os.RemoveAll(hooksDir); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("remove hooks dir: %w", err)
	}

	return nil
}
