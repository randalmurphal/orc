// Package git provides git operations for orc.
package git

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// DefaultProtectedBranches is the list of branches that should never be pushed to directly.
var DefaultProtectedBranches = []string{"main", "master", "develop", "release"}

// HookConfig contains configuration for worktree hook injection.
type HookConfig struct {
	// ProtectedBranches is the list of branches that should be protected from direct pushes.
	// Defaults to DefaultProtectedBranches if empty.
	ProtectedBranches []string

	// TaskBranch is the expected branch name for this worktree.
	TaskBranch string

	// TaskID is the task identifier for logging purposes.
	TaskID string
}

// InjectWorktreeHooks injects safety hooks into a worktree's git directory.
// These hooks prevent pushing to protected branches and validate that commits
// are made on the expected task branch.
//
// Hooks are stored in .git/worktrees/<worktree-name>/hooks/ and configured
// via core.hooksPath in the worktree's local config. This ensures:
// - Hooks are ephemeral (deleted with worktree cleanup)
// - Hooks don't conflict with the main repo's hooks
// - Each task gets isolated enforcement
func (g *Git) InjectWorktreeHooks(worktreePath string, cfg HookConfig) error {
	// Get the worktree's git directory (e.g., .git/worktrees/orc-TASK-001)
	worktreeGitDir, err := g.getWorktreeGitDir(worktreePath)
	if err != nil {
		return fmt.Errorf("get worktree git dir: %w", err)
	}

	hooksDir := filepath.Join(worktreeGitDir, "hooks")
	if err := os.MkdirAll(hooksDir, 0755); err != nil {
		return fmt.Errorf("create hooks dir: %w", err)
	}

	protectedBranches := cfg.ProtectedBranches
	if len(protectedBranches) == 0 {
		protectedBranches = DefaultProtectedBranches
	}

	// Write pre-push hook
	prePushContent := generatePrePushHook(cfg.TaskBranch, cfg.TaskID, protectedBranches)
	if err := writeExecutableFile(filepath.Join(hooksDir, "pre-push"), prePushContent); err != nil {
		return fmt.Errorf("write pre-push hook: %w", err)
	}

	// Write pre-commit hook
	preCommitContent := generatePreCommitHook(cfg.TaskBranch, cfg.TaskID)
	if err := writeExecutableFile(filepath.Join(hooksDir, "pre-commit"), preCommitContent); err != nil {
		return fmt.Errorf("write pre-commit hook: %w", err)
	}

	// Configure worktree to use these hooks by writing directly to worktree config.
	// IMPORTANT: Using `git config --local` writes to the main repo's .git/config,
	// which would incorrectly apply hooks to ALL repositories including main.
	// Instead, we write directly to .git/worktrees/<name>/config to ensure hooks
	// only apply to this specific worktree.
	worktreeConfigPath := filepath.Join(worktreeGitDir, "config")
	configContent := fmt.Sprintf("[core]\n\thooksPath = %s\n", hooksDir)
	if err := os.WriteFile(worktreeConfigPath, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("write worktree config: %w", err)
	}

	return nil
}

// getWorktreeGitDir returns the git directory for a worktree.
// For a worktree at .orc/worktrees/orc-TASK-001, this returns
// .git/worktrees/orc-TASK-001 (the actual git metadata directory).
func (g *Git) getWorktreeGitDir(worktreePath string) (string, error) {
	// Read the .git file in the worktree to find the actual git dir
	gitFile := filepath.Join(worktreePath, ".git")
	content, err := os.ReadFile(gitFile)
	if err != nil {
		return "", fmt.Errorf("read .git file: %w", err)
	}

	// Parse "gitdir: /path/to/.git/worktrees/name"
	line := strings.TrimSpace(string(content))
	if !strings.HasPrefix(line, "gitdir: ") {
		return "", fmt.Errorf("invalid .git file format: %s", line)
	}

	gitDir := strings.TrimPrefix(line, "gitdir: ")
	return gitDir, nil
}

// generatePrePushHook generates a pre-push hook that blocks pushes to protected branches.
// The hook includes worktree detection to prevent false positives when the hook
// is accidentally triggered from the main repository.
func generatePrePushHook(taskBranch, taskID string, protectedBranches []string) string {
	if len(protectedBranches) == 0 {
		protectedBranches = DefaultProtectedBranches
	}
	protected := strings.Join(protectedBranches, " ")

	return fmt.Sprintf(`#!/bin/bash
# Orc worktree safety hook - prevents pushing to protected branches
# Task: %s
# Branch: %s
# Generated by orc - DO NOT EDIT

set -e

PROTECTED_BRANCHES="%s"
TASK_BRANCH="%s"
TASK_ID="%s"

# Detect if we're actually in a worktree by checking the .git entry.
# In a worktree, .git is a file containing "gitdir: /path/to/.git/worktrees/<name>"
# In the main repo, .git is a directory.
GIT_DIR_ENTRY=$(git rev-parse --git-dir 2>/dev/null)

# If we're not in a worktree (git-dir doesn't contain "worktrees"), skip validation.
# This prevents false positives when hooks are accidentally applied to the main repo.
if [[ ! "$GIT_DIR_ENTRY" =~ worktrees/ ]]; then
    exit 0
fi

while read local_ref local_sha remote_ref remote_sha; do
    # Extract the remote branch name
    remote_branch="${remote_ref#refs/heads/}"

    # Check against protected branches
    for protected in $PROTECTED_BRANCHES; do
        if [ "$remote_branch" = "$protected" ]; then
            echo ""
            echo "==============================================="
            echo "  BLOCKED: Push to protected branch '$protected'"
            echo "==============================================="
            echo ""
            echo "  Task: $TASK_ID"
            echo "  Task Branch: $TASK_BRANCH"
            echo ""
            echo "  Direct pushes to protected branches are not allowed."
            echo "  Use the PR workflow instead:"
            echo "    orc run $TASK_ID  # Creates PR automatically"
            echo ""
            exit 1
        fi
    done
done

exit 0
`, taskID, taskBranch, protected, taskBranch, taskID)
}

// generatePreCommitHook generates a pre-commit hook that validates the current branch.
// The hook includes worktree detection to prevent false positives when the hook
// is accidentally triggered from the main repository.
func generatePreCommitHook(taskBranch, taskID string) string {
	return fmt.Sprintf(`#!/bin/bash
# Orc worktree safety hook - validates commits are on expected branch
# Task: %s
# Branch: %s
# Generated by orc - DO NOT EDIT

set -e

EXPECTED_BRANCH="%s"
TASK_ID="%s"

# Detect if we're actually in a worktree by checking the .git entry.
# In a worktree, .git is a file containing "gitdir: /path/to/.git/worktrees/<name>"
# In the main repo, .git is a directory.
GIT_DIR_ENTRY=$(git rev-parse --git-dir 2>/dev/null)

# If we're not in a worktree (git-dir doesn't contain "worktrees"), skip validation.
# This prevents false positives when hooks are accidentally applied to the main repo.
if [[ ! "$GIT_DIR_ENTRY" =~ worktrees/ ]]; then
    exit 0
fi

CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

if [ "$CURRENT_BRANCH" != "$EXPECTED_BRANCH" ]; then
    echo ""
    echo "==============================================="
    echo "  WARNING: Unexpected branch for task"
    echo "==============================================="
    echo ""
    echo "  Task: $TASK_ID"
    echo "  Expected branch: $EXPECTED_BRANCH"
    echo "  Current branch: $CURRENT_BRANCH"
    echo ""
    echo "  This worktree is configured for a specific task."
    echo "  Commits should be made on the task branch."
    echo ""
    # Allow the commit but warn - user might have legitimate reason
    # The pre-push hook will still block pushes to protected branches
fi

exit 0
`, taskID, taskBranch, taskBranch, taskID)
}

// writeExecutableFile writes content to a file and makes it executable.
func writeExecutableFile(path, content string) error {
	return os.WriteFile(path, []byte(content), 0755)
}

// IsProtectedBranch checks if a branch name is in the protected list.
func IsProtectedBranch(branch string, protectedBranches []string) bool {
	if len(protectedBranches) == 0 {
		protectedBranches = DefaultProtectedBranches
	}
	for _, p := range protectedBranches {
		if branch == p {
			return true
		}
	}
	return false
}

// RemoveWorktreeHooks removes the injected hooks from a worktree.
// This is called during worktree cleanup.
func (g *Git) RemoveWorktreeHooks(worktreePath string) error {
	worktreeGitDir, err := g.getWorktreeGitDir(worktreePath)
	if err != nil {
		// Worktree might already be partially cleaned up - log but don't fail
		fmt.Fprintf(os.Stderr, "warning: could not get worktree git dir for hook cleanup: %v\n", err)
		return nil
	}

	hooksDir := filepath.Join(worktreeGitDir, "hooks")
	if err := os.RemoveAll(hooksDir); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("remove hooks dir: %w", err)
	}

	return nil
}

// EnsureClaudeSettingsUntracked marks .claude/settings.json as "assume-unchanged"
// in git, so local modifications don't appear as dirty working tree state.
// This ensures machine-specific worktree hooks don't interfere with git rebase/merge.
//
// This is necessary because:
// 1. Worktree isolation hooks contain machine-specific absolute paths
// 2. These paths differ between machines (Mac vs Linux, different users)
// 3. If git sees the file as modified, rebase fails with "unstaged changes" error
// 4. Using --assume-unchanged tells git to ignore local modifications
//
// The function also adds the file to local git exclude to prevent accidental commits.
// The function is idempotent - safe to call multiple times.
func EnsureClaudeSettingsUntracked(worktreePath string) error {
	settingsRelPath := ".claude/settings.json"

	// Check if file is tracked by git
	cmd := execCommand("git", "ls-files", settingsRelPath)
	cmd.Dir = worktreePath
	output, err := cmd.Output()
	if err != nil {
		// git ls-files failed, might not be a git repo - skip
		return nil
	}

	if strings.TrimSpace(string(output)) != "" {
		// File is tracked - mark as assume-unchanged so git ignores local modifications.
		// This allows rebase/merge to proceed without seeing the file as dirty.
		cmd = execCommand("git", "update-index", "--assume-unchanged", settingsRelPath)
		cmd.Dir = worktreePath
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("mark %s as assume-unchanged: %w", settingsRelPath, err)
		}
	}

	// Add to local git exclude to prevent accidental staging/commits
	return addToGitExclude(worktreePath, settingsRelPath)
}

// addToGitExclude adds a path to the worktree's local git exclude file.
// For worktrees, this is in .git/worktrees/<name>/info/exclude.
func addToGitExclude(worktreePath, pattern string) error {
	// Find the git directory for this worktree
	gitFile := filepath.Join(worktreePath, ".git")
	content, err := os.ReadFile(gitFile)
	if err != nil {
		// Might be a regular repo or .git doesn't exist - try standard path
		return addToExcludeFile(filepath.Join(worktreePath, ".git", "info", "exclude"), pattern)
	}

	// Parse "gitdir: /path/to/.git/worktrees/name"
	line := strings.TrimSpace(string(content))
	if !strings.HasPrefix(line, "gitdir: ") {
		// Not a worktree format, use standard path
		return addToExcludeFile(filepath.Join(worktreePath, ".git", "info", "exclude"), pattern)
	}

	gitDir := strings.TrimPrefix(line, "gitdir: ")
	excludePath := filepath.Join(gitDir, "info", "exclude")
	return addToExcludeFile(excludePath, pattern)
}

// addToExcludeFile adds a pattern to a git exclude file if not already present.
func addToExcludeFile(excludePath, pattern string) error {
	// Ensure the info directory exists
	infoDir := filepath.Dir(excludePath)
	if err := os.MkdirAll(infoDir, 0755); err != nil {
		return fmt.Errorf("create info dir: %w", err)
	}

	// Read existing content
	existingContent, err := os.ReadFile(excludePath)
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("read exclude file: %w", err)
	}

	// Check if pattern already exists
	lines := strings.Split(string(existingContent), "\n")
	for _, line := range lines {
		if strings.TrimSpace(line) == pattern {
			// Already excluded
			return nil
		}
	}

	// Append pattern
	var newContent string
	if len(existingContent) > 0 && !strings.HasSuffix(string(existingContent), "\n") {
		newContent = string(existingContent) + "\n" + pattern + "\n"
	} else {
		newContent = string(existingContent) + pattern + "\n"
	}

	if err := os.WriteFile(excludePath, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("write exclude file: %w", err)
	}

	return nil
}

// execCommand is a variable to allow test mocking of exec.Command.
var execCommand = exec.Command
