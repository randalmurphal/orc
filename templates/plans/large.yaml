version: 1
weight: large
description: Large task - spec, design, implement, review, test, docs, validate with multi-agent code review

phases:
  - id: spec
    name: spec
    prompt: |
      Create a specification for this large task:

      **Task**: {{TASK_TITLE}}

      **Description**: {{TASK_DESCRIPTION}}

      Define:
      1. Requirements and scope
      2. Technical approach
      3. Component breakdown (backend, frontend if applicable)
      4. API design (if applicable)
      5. Success criteria with explicit checkboxes
      6. Testing strategy:
         - Unit tests
         - Integration tests
         - E2E tests (using Playwright MCP tools if frontend exists)

      Include clear completion criteria:
      - What code must be written
      - What tests must pass
      - What E2E scenarios must work
      - What documentation must exist

      Keep iterating until the specification is clear and complete.

      When done, output:
      <phase_complete>true</phase_complete>
    depends_on: []
    gate:
      type: auto
    checkpoint: true

  - id: design
    name: design
    prompt: |
      Create architecture and design for:

      **Task**: {{TASK_TITLE}}

      **Description**: {{TASK_DESCRIPTION}}

      **Specification**:
      {{SPEC_CONTENT}}

      Design requirements:
      1. Define components and their responsibilities
      2. Document design decisions with rationale
      3. Assess implementation risks
      4. Define implementation order

      Output a design document with:
      - Component architecture
      - Design decisions table (DD-1, DD-2, etc.)
      - Risk assessment
      - Implementation order

      When done, output:
      <phase_complete>true</phase_complete>
    depends_on: [spec]
    gate:
      type: auto
    checkpoint: true

  - id: implement
    name: implement
    prompt: |
      Implement the large task according to the specification and design:

      **Task**: {{TASK_TITLE}}

      **Description**: {{TASK_DESCRIPTION}}

      **Specification**:
      {{SPEC_CONTENT}}

      **Design**:
      {{DESIGN_CONTENT}}

      {{RETRY_CONTEXT}}

      Implementation protocol:
      1. Follow the design's implementation order
      2. Implement all components defined in the spec
      3. Write unit tests alongside code
      4. Run tests frequently: `go test ./... -v -race`
      5. Fix failures before continuing
      6. If frontend exists:
         - Implement all components
         - Add loading/error states
         - Integrate with API

      Keep iterating until:
      - All components implemented
      - All unit tests pass
      - No race conditions

      When done, output:
      <phase_complete>true</phase_complete>
    depends_on: [design]
    gate:
      type: auto
    checkpoint: true

  - id: review
    name: review
    prompt_file: review.md
    depends_on: [implement]
    gate:
      type: auto
    checkpoint: true
    max_iterations: 3

  - id: test
    name: test
    prompt: |
      Comprehensive testing for:

      **Task**: {{TASK_TITLE}}

      **Description**: {{TASK_DESCRIPTION}}

      ## Unit Tests
      1. Run: `go test ./... -v -race -cover`
      2. Verify coverage > 80%
      3. Fix any failures

      ## Integration Tests
      1. Test component interactions
      2. Test error handling paths
      3. Verify data flows correctly

      ## E2E Tests (If frontend exists - Use Playwright MCP tools)

      Setup:
      - Start backend server
      - Start frontend server

      Test using Playwright MCP:
      1. `mcp__playwright__browser_navigate` to app URL
      2. `mcp__playwright__browser_snapshot` to verify state
      3. `mcp__playwright__browser_click` to interact
      4. `mcp__playwright__browser_type` for input
      5. `mcp__playwright__browser_wait_for` for async operations

      Critical scenarios:
      - Happy path user flow
      - Error handling
      - Edge cases

      Keep iterating until all tests pass.

      When done, output:
      <phase_complete>true</phase_complete>
    depends_on: [review]
    gate:
      type: auto
    checkpoint: true

  - id: docs
    name: docs
    prompt: |
      Update documentation for:

      **Task**: {{TASK_TITLE}}

      **Description**: {{TASK_DESCRIPTION}}

      1. Update any relevant documentation files
      2. Ensure CLAUDE.md reflects the changes if applicable
      3. Add/update code comments where needed
      4. Update README if user-facing changes were made

      Keep iterating until documentation is complete.

      When done, output:
      <phase_complete>true</phase_complete>
    depends_on: [test]
    gate:
      type: auto
    checkpoint: true

  - id: validate
    name: validate
    prompt: |
      Final validation for:

      **Task**: {{TASK_TITLE}}

      **Description**: {{TASK_DESCRIPTION}}

      ## Validation Checklist

      ### Code
      - [ ] All requirements from spec are met
      - [ ] Unit tests pass: `go test ./... -v -race`
      - [ ] Test coverage > 80%
      - [ ] No race conditions
      - [ ] Code quality acceptable (no debug statements, TODOs)

      ### Integration
      - [ ] Components work together
      - [ ] Error handling is complete
      - [ ] Performance is acceptable

      ### E2E (If frontend - MUST RUN with Playwright MCP)
      - [ ] Main user flows work
      - [ ] Error states handled
      - [ ] UI updates correctly

      ### Documentation
      - [ ] Code is documented where needed
      - [ ] CLAUDE.md updated if necessary
      - [ ] API documented if applicable

      ## Final Verification

      If frontend exists, run E2E verification:
      1. Start all servers
      2. Use Playwright MCP tools to test all features
      3. Verify everything works end-to-end

      Keep iterating until validation passes.

      When done, output:
      <phase_complete>true</phase_complete>
    depends_on: [docs]
    gate:
      type: auto
    checkpoint: true
