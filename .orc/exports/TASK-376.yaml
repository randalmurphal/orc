version: 2
exported_at: 2026-01-16T23:27:36.904168272-06:00
task:
    id: TASK-376
    title: Final visual regression test suite for all views
    description: "Create a comprehensive visual regression test suite for all views.\n\nREFERENCE FILES:\n- All example_ui/*.html files\n- All example_ui/Screenshot_*.png files\n\nPURPOSE:\nThis task creates a reusable test suite that can be run on every PR to catch visual regressions. It consolidates all view-specific tests and adds cross-cutting checks.\n\nTEST STRUCTURE:\n```typescript\n// web/e2e/visual/regression.spec.ts\nimport { test, expect } from \"../fixtures\";\n\nconst VIEWS = [\n  { path: \"/board\", name: \"board\", snapshotName: \"board-full.png\" },\n  { path: \"/initiatives\", name: \"initiatives\", snapshotName: \"initiatives-full.png\" },\n  { path: \"/stats\", name: \"stats\", snapshotName: \"stats-full.png\" },\n  { path: \"/agents\", name: \"agents\", snapshotName: \"agents-full.png\" },\n  { path: \"/settings\", name: \"settings\", snapshotName: \"settings-full.png\" },\n];\n\ntest.describe(\"Visual Regression Suite\", () => {\n  test.beforeAll(async ({ request }) => {\n    // Seed comprehensive test data\n    await request.post(\"/api/test/seed\", {\n      data: {\n        initiatives: 5,\n        tasks: 50,\n        runningTasks: 3,\n        blockedTasks: 2,\n        completedTasks: 100,\n      }\n    });\n  });\n\n  for (const view of VIEWS) {\n    test(`${view.name} view matches baseline`, async ({ page }) => {\n      await page.goto(view.path);\n      await page.waitForLoadState(\"networkidle\");\n      await page.waitForFunction(() => document.fonts.ready);\n      \n      // Wait for any animations to settle\n      await page.waitForTimeout(500);\n      \n      await expect(page).toHaveScreenshot(view.snapshotName, {\n        maxDiffPixelRatio: 0.01,\n        threshold: 0.2,\n      });\n    });\n  }\n\n  test(\"Navigation between views works\", async ({ page }) => {\n    await page.goto(\"/board\");\n    \n    // Click each nav item and verify navigation\n    await page.click(\"[href=\\\"/initiatives\\\"]\");\n    await expect(page).toHaveURL(/initiatives/);\n    \n    await page.click(\"[href=\\\"/stats\\\"]\");\n    await expect(page).toHaveURL(/stats/);\n    \n    await page.click(\"[href=\\\"/agents\\\"]\");\n    await expect(page).toHaveURL(/agents/);\n    \n    await page.click(\"[href=\\\"/settings\\\"]\");\n    await expect(page).toHaveURL(/settings/);\n    \n    await page.click(\"[href=\\\"/board\\\"]\");\n    await expect(page).toHaveURL(/board/);\n  });\n\n  test(\"Active nav state updates correctly\", async ({ page }) => {\n    for (const view of VIEWS) {\n      await page.goto(view.path);\n      \n      const activeNav = page.locator(\".nav-item.active\");\n      await expect(activeNav).toHaveAttribute(\"href\", view.path);\n    }\n  });\n\n  test(\"Consistent typography across views\", async ({ page }) => {\n    for (const view of VIEWS) {\n      await page.goto(view.path);\n      \n      // Verify Inter font is loaded\n      const fontFamily = await page.evaluate(() => \n        getComputedStyle(document.body).fontFamily\n      );\n      expect(fontFamily).toContain(\"Inter\");\n    }\n  });\n\n  test(\"Consistent color tokens across views\", async ({ page }) => {\n    for (const view of VIEWS) {\n      await page.goto(view.path);\n      \n      // Verify background color\n      const bgColor = await page.evaluate(() => \n        getComputedStyle(document.body).backgroundColor\n      );\n      // #050508 = rgb(5, 5, 8)\n      expect(bgColor).toBe(\"rgb(5, 5, 8)\");\n    }\n  });\n\n  test(\"Responsive breakpoints work\", async ({ page }) => {\n    const breakpoints = [\n      { width: 1920, height: 1080, name: \"desktop\" },\n      { width: 1024, height: 768, name: \"tablet-landscape\" },\n      { width: 768, height: 1024, name: \"tablet-portrait\" },\n      { width: 375, height: 812, name: \"mobile\" },\n    ];\n\n    for (const bp of breakpoints) {\n      await page.setViewportSize({ width: bp.width, height: bp.height });\n      await page.goto(\"/board\");\n      await page.waitForLoadState(\"networkidle\");\n      \n      await expect(page).toHaveScreenshot(`board-${bp.name}.png`, {\n        maxDiffPixelRatio: 0.02,\n      });\n    }\n  });\n});\n```\n\nCONFIGURATION:\n```typescript\n// playwright.config.ts additions\n{\n  projects: [\n    {\n      name: \"visual\",\n      testDir: \"./e2e/visual\",\n      use: {\n        ...devices[\"Desktop Chrome\"],\n      },\n      snapshotDir: \"./e2e/visual/snapshots\",\n    },\n  ],\n  expect: {\n    toHaveScreenshot: {\n      maxDiffPixels: 500,\n      threshold: 0.2,\n    },\n  },\n}\n```\n\nSUCCESS CRITERIA:\n1. Visual regression test suite at web/e2e/visual/regression.spec.ts\n2. Baseline screenshots captured for all 5 views\n3. Tests pass on CI with visual comparison\n4. Responsive breakpoint tests included\n5. Cross-view consistency tests included\n6. npm run test:visual runs all visual tests\n7. Documentation for updating baselines\n\nSCRIPT ADDITIONS:\n```json\n// package.json\n{\n  \"scripts\": {\n    \"test:visual\": \"playwright test --project=visual\",\n    \"test:visual:update\": \"playwright test --project=visual --update-snapshots\"\n  }\n}\n```\n\nFILES TO CREATE:\n- web/e2e/visual/regression.spec.ts\n- web/e2e/visual/snapshots/ (baseline images)\n\nFILES TO MODIFY:\n- web/playwright.config.ts\n- web/package.json"
    weight: large
    status: planned
    branch: orc/TASK-376
    queue: active
    priority: high
    category: test
    initiative_id: INIT-022
    blocked_by:
        - TASK-371
        - TASK-372
        - TASK-373
        - TASK-374
        - TASK-375
    created_at: 2026-01-16T21:04:38-06:00
    updated_at: 0001-01-01T00:00:00Z
plan:
    version: 1
    task_id: TASK-376
    weight: large
    description: Large task - spec, design, implement, review, test, docs, validate with multi-agent code review
    phases:
        - id: spec
          name: spec
          prompt: |
            Create a specification for this large task:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            Define:
            1. Requirements and scope
            2. Technical approach
            3. Component breakdown (backend, frontend if applicable)
            4. API design (if applicable)
            5. Success criteria with explicit checkboxes
            6. Testing strategy:
               - Unit tests
               - Integration tests
               - E2E tests (using Playwright MCP tools if frontend exists)

            Include clear completion criteria:
            - What code must be written
            - What tests must pass
            - What E2E scenarios must work
            - What documentation must exist

            Keep iterating until the specification is clear and complete.

            When done, output:
            <phase_complete>true</phase_complete>
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: design
          name: design
          prompt: |
            Create architecture and design for:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            **Specification**:
            {{SPEC_CONTENT}}

            Design requirements:
            1. Define components and their responsibilities
            2. Document design decisions with rationale
            3. Assess implementation risks
            4. Define implementation order

            Output a design document with:
            - Component architecture
            - Design decisions table (DD-1, DD-2, etc.)
            - Risk assessment
            - Implementation order

            When done, output:
            <phase_complete>true</phase_complete>
          depends_on:
            - spec
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: implement
          name: implement
          prompt: |
            Implement the large task according to the specification and design:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            **Specification**:
            {{SPEC_CONTENT}}

            **Design**:
            {{DESIGN_CONTENT}}

            {{RETRY_CONTEXT}}

            Implementation protocol:
            1. Follow the design's implementation order
            2. Implement all components defined in the spec
            3. Write unit tests alongside code
            4. Run tests frequently: `go test ./... -v -race`
            5. Fix failures before continuing
            6. If frontend exists:
               - Implement all components
               - Add loading/error states
               - Integrate with API

            Keep iterating until:
            - All components implemented
            - All unit tests pass
            - No race conditions

            When done, output:
            <phase_complete>true</phase_complete>
          depends_on:
            - design
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: review
          name: review
          prompt: ""
          depends_on:
            - implement
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: test
          name: test
          prompt: |
            Comprehensive testing for:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            ## Unit Tests
            1. Run: `go test ./... -v -race -cover`
            2. Verify coverage > 80%
            3. Fix any failures

            ## Integration Tests
            1. Test component interactions
            2. Test error handling paths
            3. Verify data flows correctly

            ## E2E Tests (If frontend exists - Use Playwright MCP tools)

            Setup:
            - Start backend server
            - Start frontend server

            Test using Playwright MCP:
            1. `mcp__playwright__browser_navigate` to app URL
            2. `mcp__playwright__browser_snapshot` to verify state
            3. `mcp__playwright__browser_click` to interact
            4. `mcp__playwright__browser_type` for input
            5. `mcp__playwright__browser_wait_for` for async operations

            Critical scenarios:
            - Happy path user flow
            - Error handling
            - Edge cases

            Keep iterating until all tests pass.

            When done, output:
            <phase_complete>true</phase_complete>
          depends_on:
            - review
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: docs
          name: docs
          prompt: |
            Update documentation for:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            1. Update any relevant documentation files
            2. Ensure CLAUDE.md reflects the changes if applicable
            3. Add/update code comments where needed
            4. Update README if user-facing changes were made

            Keep iterating until documentation is complete.

            When done, output:
            <phase_complete>true</phase_complete>
          depends_on:
            - test
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: validate
          name: validate
          prompt: |
            Final validation for:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            ## Validation Checklist

            ### Code
            - [ ] All requirements from spec are met
            - [ ] Unit tests pass: `go test ./... -v -race`
            - [ ] Test coverage > 80%
            - [ ] No race conditions
            - [ ] Code quality acceptable (no debug statements, TODOs)

            ### Integration
            - [ ] Components work together
            - [ ] Error handling is complete
            - [ ] Performance is acceptable

            ### E2E (If frontend - MUST RUN with Playwright MCP)
            - [ ] Main user flows work
            - [ ] Error states handled
            - [ ] UI updates correctly

            ### Documentation
            - [ ] Code is documented where needed
            - [ ] CLAUDE.md updated if necessary
            - [ ] API documented if applicable

            ## Final Verification

            If frontend exists, run E2E verification:
            1. Start all servers
            2. Use Playwright MCP tools to test all features
            3. Verify everything works end-to-end

            Keep iterating until validation passes.

            When done, output:
            <phase_complete>true</phase_complete>
          depends_on:
            - docs
          gate:
            type: auto
          checkpoint: true
          status: pending
state:
    task_id: TASK-376
    current_phase: ""
    current_iteration: 0
    status: pending
    started_at: 0001-01-01T00:00:00Z
    updated_at: 0001-01-01T00:00:00Z
    phases: {}
    tokens:
        input_tokens: 0
        output_tokens: 0
        total_tokens: 0
    cost:
        total_cost_usd: 0
