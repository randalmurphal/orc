version: 2
exported_at: 2026-01-17T08:29:48.007622-06:00
task:
    id: TASK-198
    title: 'Fix: Re-running completed tasks fails to push due to diverged remote branch'
    description: 'When a task is re-run after being previously completed and pushed, the completion action fails with ''non-fast-forward'' error because the remote branch has different history from the new run. Current workaround requires manual force push. Options: 1) Detect diverged remote and force push automatically, 2) Delete remote branch before re-run, 3) Rebase onto remote before push. Should also consider if this is the right behavior - maybe re-runs should continue from remote state instead of starting fresh.'
    weight: medium
    status: completed
    current_phase: docs
    branch: orc/TASK-198
    queue: active
    priority: high
    category: bug
    created_at: 2026-01-14T22:00:33-06:00
    updated_at: 0001-01-01T00:00:00Z
    started_at: 2026-01-14T22:19:24-06:00
plan:
    version: 1
    task_id: TASK-198
    weight: medium
    description: Medium task - spec, implement, test, docs with clear success criteria
    phases:
        - id: spec
          name: spec
          prompt: |
            Create a specification for this task:

            **Task**: {{TASK_TITLE}}
            **Category**: {{TASK_CATEGORY}}
            **Description**: {{TASK_DESCRIPTION}}

            {{INITIATIVE_CONTEXT}}

            ## Instructions

            Create a clear, actionable specification that defines exactly what needs to be done
            and how to verify it's complete.

            ### 1. Problem Statement
            Summarize what needs to be solved in 1-2 sentences.

            ### 2. Success Criteria (REQUIRED)
            Define specific, testable criteria as checkboxes:
            - Each criterion must be verifiable (file exists, test passes, API returns X)
            - No vague language ("works well", "is fast")
            - Include both functional and quality criteria

            ### 3. Testing Requirements (REQUIRED)
            Specify what tests must pass:
            - [ ] Unit test: [specific test description]
            - [ ] Integration test: [if applicable]
            - [ ] E2E test: [if UI changes]

            ### 4. Scope
            Define boundaries to prevent scope creep:
            - **In Scope**: What will be implemented
            - **Out of Scope**: What will NOT be implemented

            ### 5. Technical Approach
            Brief plan for implementation:
            - Files to modify
            - Key changes in each file

            ### 6. Category-Specific Analysis

            **If this is a BUG (category=bug):**
            - Reproduction Steps: Exact steps to trigger the bug
            - Current Behavior: What happens now (the bug)
            - Expected Behavior: What should happen
            - Root Cause: Where the bug originates (if known)
            - Verification: How to confirm the fix works

            **If this is a FEATURE (category=feature):**
            - User Story: As a [user], I want [feature] so that [benefit]
            - Acceptance Criteria: Specific conditions for feature acceptance

            **If this is a REFACTOR (category=refactor):**
            - Before Pattern: Current code/architecture
            - After Pattern: Target code/architecture
            - Risk Assessment: What could break

            ## Output Format

            Wrap your spec in artifact tags:

            <artifact>
            # Specification: {{TASK_TITLE}}

            ## Problem Statement
            [1-2 sentences]

            ## Success Criteria
            - [ ] [Criterion 1]
            - [ ] [Criterion 2]

            ## Testing Requirements
            - [ ] [Test 1]
            - [ ] [Test 2]

            ## Scope
            ### In Scope
            - [Item]
            ### Out of Scope
            - [Item]

            ## Technical Approach
            [Brief implementation plan]

            ### Files to Modify
            - [file]: [change]

            ## [Category-Specific Section]
            [Include appropriate section based on category]
            </artifact>

            After completing the spec, commit:
            ```bash
            git add -A
            git commit -m "[orc] {{TASK_ID}}: spec - completed"
            ```

            Then output:
            ```
            **Commit**: [SHA]
            <phase_complete>true</phase_complete>
            ```

            If blocked (requirements unclear):
            ```
            <phase_blocked>
            reason: [what's unclear]
            needs: [what clarification is needed]
            </phase_blocked>
            ```
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: implement
          name: implement
          prompt: |
            Implement the task according to the specification:

            **Task**: {{TASK_TITLE}}
            **Category**: {{TASK_CATEGORY}}

            {{INITIATIVE_CONTEXT}}

            ## Specification

            {{SPEC_CONTENT}}

            {{RETRY_CONTEXT}}

            ## Instructions

            1. Review the spec's success criteria - these are your acceptance criteria
            2. Implement the required changes following the technical approach
            3. Write/update tests alongside code (as specified in Testing Requirements)
            4. Run tests and fix any failures
            5. Self-review against success criteria before completing

            ### Self-Review Checklist
            - [ ] All success criteria from spec addressed
            - [ ] All testing requirements satisfied
            - [ ] Scope boundaries respected (no extra features)
            - [ ] Error handling complete
            - [ ] Code follows project patterns

            Keep iterating until implementation is complete and tests pass.

            After completing, commit:
            ```bash
            git add -A
            git commit -m "[orc] {{TASK_ID}}: implement - completed"
            ```

            When done, output:
            ```
            **Commit**: [SHA]
            <phase_complete>true</phase_complete>
            ```
          depends_on:
            - spec
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: test
          name: test
          prompt: |
            Test and review the implementation:

            **Task**: {{TASK_TITLE}}
            **Category**: {{TASK_CATEGORY}}

            ## Specification

            {{SPEC_CONTENT}}

            ## Instructions

            1. Run the full test suite
            2. Verify all Testing Requirements from spec are satisfied
            3. Review code for quality issues
            4. Check for edge cases and security issues
            5. Fix any problems found

            ### Verification Against Spec
            Go through each Success Criterion and Testing Requirement from the spec
            and verify it's satisfied.

            Keep iterating until all tests pass and code quality is acceptable.

            After completing, commit:
            ```bash
            git add -A
            git commit -m "[orc] {{TASK_ID}}: test - completed"
            ```

            When done, output:
            ```
            **Commit**: [SHA]
            <phase_complete>true</phase_complete>
            ```
          depends_on:
            - implement
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: docs
          name: docs
          prompt: |
            Update documentation for:

            **Task**: {{TASK_TITLE}}
            **Category**: {{TASK_CATEGORY}}

            ## Specification

            {{SPEC_CONTENT}}

            ## Instructions

            1. Update any relevant documentation files
            2. Ensure CLAUDE.md reflects the changes if applicable
            3. Add/update code comments where needed
            4. Update README if user-facing changes were made

            Keep iterating until documentation is complete.

            After completing, commit:
            ```bash
            git add -A
            git commit -m "[orc] {{TASK_ID}}: docs - completed"
            ```

            When done, output:
            ```
            **Commit**: [SHA]
            <phase_complete>true</phase_complete>
            ```
          depends_on:
            - test
          gate:
            type: auto
          checkpoint: true
          status: pending
spec: |
    # Specification: Fix: Re-running completed tasks fails to push due to diverged remote branch

    ## Problem Statement

    When a task is re-run after previously completing (which includes pushing to remote), the completion action fails with 'non-fast-forward' error because the local branch has been reset to a fresh state based on the target branch, but the remote still has the old commits from the previous run. This requires manual force push to resolve.

    ## Root Cause Analysis

    The issue occurs in this sequence:
    1. Task TASK-001 runs successfully, branch `orc/TASK-001` is pushed to origin
    2. User wants to re-run the task (e.g., to incorporate review feedback)
    3. Worktree is recreated from the target branch (main), getting a fresh start
    4. Task executes, creating new commits
    5. At completion, `Push()` in `internal/git/git.go:385` calls `devflow.Push()`
    6. Push fails because local history diverges from `origin/orc/TASK-001`

    The current `Push()` implementation (`internal/git/git.go:385-390`) wraps `devflow.Push()` which uses standard `git push` without force:
    ```go
    func (g *Git) Push(remote, branch string, setUpstream bool) error {
        if IsProtectedBranch(branch, g.protectedBranches) {
            return fmt.Errorf("%w: cannot push to '%s'", ErrProtectedBranch, branch)
        }
        return g.ctx.Push(remote, branch, setUpstream)
    }
    ```

    ## Design Decision: Sync with Remote Before Reset

    After analysis, the best approach is **Option 3: Sync with remote before starting fresh**. Rather than force-pushing (destructive) or deleting remote branches (loses history), we should:

    1. When re-running a completed task, detect if the remote branch exists
    2. If it does, rebase the task branch onto the remote before resetting/restarting
    3. This preserves remote history while allowing fresh work

    However, for simpler cases where a user explicitly wants to re-run from scratch (discarding all previous work), we need a **force push with safeguards** approach as a fallback.

    ## Success Criteria

    - [ ] Re-running a completed task succeeds without manual intervention
    - [ ] Force push is only used for task branches (never for protected branches like main/master)
    - [ ] User is warned when force push will occur (in non-quiet mode)
    - [ ] Existing behavior for first-time runs is unchanged (no regression)
    - [ ] The solution handles both scenarios:
      - [ ] Scenario A: Re-run keeping remote commits (default) - sync with remote first
      - [ ] Scenario B: Re-run from scratch (--fresh flag) - force push to overwrite
    - [ ] Configuration option to control force push behavior (`completion.push.allow_force`)
    - [ ] Push failure logs clear message explaining why it failed and how to resolve

    ## Testing Requirements

    - [ ] Unit test: `TestPushForce_TaskBranch` - verify force push works for task branches
    - [ ] Unit test: `TestPushForce_ProtectedBranch` - verify force push blocked for protected branches
    - [ ] Unit test: `TestDetectRemoteBranchExists` - verify remote branch detection
    - [ ] Unit test: `TestSyncWithRemoteBranch` - verify rebase onto remote before re-run
    - [ ] Integration test: Re-run completed task without --fresh flag syncs with remote
    - [ ] Integration test: Re-run completed task with --fresh flag force pushes

    ## Scope

    ### In Scope
    - Add `PushForce()` method to Git wrapper with protection checks
    - Add remote branch detection helper (`RemoteBranchExists`)
    - Modify completion push logic to handle diverged branches
    - Add `--fresh` flag to `orc run` for explicit force-push behavior
    - Add configuration option `completion.push.allow_force`
    - Update error messages to guide users on resolution

    ### Out of Scope
    - Changing the worktree creation logic (keep current behavior)
    - Automatic cleanup of remote branches after merge
    - Multi-remote support (origin only for now)
    - Interactive rebase for conflict resolution (fails and prompts user)

    ## Technical Approach

    ### 1. Add Git Helper Methods

    **File: `internal/git/git.go`**

    ```go
    // PushForce pushes with --force-with-lease for safety.
    // This is safer than --force as it fails if the remote has unexpected commits.
    // SAFETY: This will NOT push to protected branches.
    func (g *Git) PushForce(remote, branch string, setUpstream bool) error {
        if IsProtectedBranch(branch, g.protectedBranches) {
            return fmt.Errorf("%w: cannot force push to '%s'", ErrProtectedBranch, branch)
        }
        // Use --force-with-lease instead of --force for extra safety
        args := []string{"push", "--force-with-lease"}
        if setUpstream {
            args = append(args, "-u")
        }
        args = append(args, remote, branch)
        _, err := g.ctx.RunGit(args...)
        return err
    }

    // RemoteBranchExists checks if a branch exists on the remote.
    func (g *Git) RemoteBranchExists(remote, branch string) (bool, error) {
        _, err := g.ctx.RunGit("ls-remote", "--heads", remote, branch)
        // Parse output to determine if branch exists
        // ...
    }

    // SyncWithRemoteBranch rebases the current branch onto the remote branch.
    // Used when re-running a task to preserve remote history.
    func (g *Git) SyncWithRemoteBranch(remote, branch string) error {
        // Fetch the remote branch first
        // Then rebase onto it
    }
    ```

    ### 2. Modify Completion Push Logic

    **File: `internal/executor/pr.go`**

    In `createPR()` around line 396:

    ```go
    // Push task branch to remote
    err := gitOps.Push("origin", taskBranch, true)
    if err != nil {
        // Check if this is a non-fast-forward error
        if isNonFastForwardError(err) {
            // Option 1: Try to sync with remote (rebase)
            // Option 2: Force push if configured/flagged
            if e.orcConfig.Completion.Push.AllowForce || e.forceRerun {
                e.logger.Warn("remote branch has diverged, force pushing",
                    "branch", taskBranch,
                    "reason", "re-run of completed task")
                if err := gitOps.PushForce("origin", taskBranch, true); err != nil {
                    return fmt.Errorf("force push branch: %w", err)
                }
            } else {
                return fmt.Errorf("push branch: %w\n"+
                    "  The remote branch has diverged (likely from a previous run).\n"+
                    "  Resolution options:\n"+
                    "    1. Run with --fresh to force push and overwrite remote\n"+
                    "    2. Manually: git push --force-with-lease origin %s\n"+
                    "    3. Set completion.push.allow_force: true in config",
                    err, taskBranch)
            }
        } else {
            return fmt.Errorf("push branch: %w", err)
        }
    }
    ```

    ### 3. Add Configuration

    **File: `internal/config/config.go`**

    Add to `CompletionConfig`:
    ```go
    type PushConfig struct {
        AllowForce bool `yaml:"allow_force"` // Allow force push for task branches
    }

    type CompletionConfig struct {
        // ... existing fields
        Push PushConfig `yaml:"push"`
    }
    ```

    ### 4. Add CLI Flag

    **File: `internal/cli/cmd_run.go`**

    ```go
    cmd.Flags().Bool("fresh", false, "force re-run from scratch (overwrites remote branch)")
    ```

    ### Files to Modify

    | File | Changes |
    |------|---------|
    | `internal/git/git.go` | Add `PushForce()`, `RemoteBranchExists()`, `SyncWithRemoteBranch()` |
    | `internal/git/git_test.go` | Add tests for new methods |
    | `internal/executor/pr.go` | Handle non-fast-forward push errors |
    | `internal/config/config.go` | Add `completion.push.allow_force` config |
    | `internal/config/defaults.go` | Set default for allow_force (false) |
    | `internal/cli/cmd_run.go` | Add `--fresh` flag |
    | `docs/specs/CONFIG_HIERARCHY.md` | Document new config option |

    ## Bug Analysis

    ### Reproduction Steps
    1. Create and run a task to completion: `orc new "Test task" && orc run TASK-001`
    2. Wait for completion (PR created, branch pushed)
    3. Reset task status: `orc edit TASK-001 --status pending`
    4. Re-run the task: `orc run TASK-001`
    5. Task executes but fails at push with "non-fast-forward" error

    ### Current Behavior
    Push fails with error:
    ```
    error: failed to push some refs to 'origin'
    hint: Updates were rejected because the tip of your current branch is behind
    hint: its remote counterpart. If you want to integrate the remote changes,
    hint: use 'git pull' before pushing again.
    ```

    ### Expected Behavior
    Re-running a task should:
    1. Default: Sync with remote branch to preserve history, then continue
    2. With `--fresh`: Force push to overwrite remote (with clear warning)

    ### Root Cause
    The worktree is recreated fresh from the target branch (main), discarding the previous run's commits. When pushing, the local branch has different ancestry than the remote branch, causing a non-fast-forward error.

    ### Verification
    1. Re-run completed task without --fresh: syncs with remote, pushes successfully
    2. Re-run completed task with --fresh: force pushes with warning
    3. Protected branches still cannot be force pushed (verify error)
    4. First-time runs work as before (no regression)
state:
    task_id: TASK-198
    current_phase: docs
    current_iteration: 0
    status: completed
    started_at: 2026-01-14T22:19:24-06:00
    updated_at: 0001-01-01T00:00:00Z
    phases:
        docs:
            status: completed
            started_at: 2026-01-14T22:28:28-06:00
            completed_at: 2026-01-14T22:30:02-06:00
            iterations: 1
            commit_sha: 76bdd21e781686bad256fe2e9b6535e9c6d5ed7c
            tokens:
                input_tokens: 1098098
                output_tokens: 3801
                total_tokens: 0
        implement:
            status: completed
            started_at: 2026-01-14T22:21:19-06:00
            completed_at: 2026-01-14T22:25:11-06:00
            iterations: 1
            commit_sha: 07629227091d3f54a30adabcb2c093ad71a979d1
            tokens:
                input_tokens: 2494991
                output_tokens: 8428
                total_tokens: 0
        spec:
            status: completed
            started_at: 2026-01-14T22:19:27-06:00
            completed_at: 2026-01-14T22:21:19-06:00
            iterations: 1
            commit_sha: 4c7b46d2ff2d29e7502e889b0c90bbcf01fb75db
            tokens:
                input_tokens: 806678
                output_tokens: 4454
                total_tokens: 0
        test:
            status: completed
            started_at: 2026-01-14T22:25:11-06:00
            completed_at: 2026-01-14T22:28:28-06:00
            iterations: 1
            commit_sha: a204a210b75a04689f867578f96186b8613b00d9
            tokens:
                input_tokens: 2459226
                output_tokens: 6876
                total_tokens: 0
    gates:
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-14T22:21:19-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-14T22:21:19-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-14T22:25:11-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-14T22:25:11-06:00
        - phase: test
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-14T22:28:28-06:00
        - phase: test
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-14T22:28:28-06:00
        - phase: docs
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-14T22:30:02-06:00
        - phase: docs
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-14T22:30:02-06:00
    tokens:
        input_tokens: 0
        output_tokens: 0
        total_tokens: 0
    cost:
        total_cost_usd: 0
gate_decisions:
    - id: 153
      taskid: TASK-198
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-14T22:21:19-06:00
    - id: 157
      taskid: TASK-198
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-14T22:21:19-06:00
    - id: 154
      taskid: TASK-198
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-14T22:25:11-06:00
    - id: 158
      taskid: TASK-198
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-14T22:25:11-06:00
    - id: 155
      taskid: TASK-198
      phase: test
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-14T22:28:28-06:00
    - id: 159
      taskid: TASK-198
      phase: test
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-14T22:28:28-06:00
    - id: 156
      taskid: TASK-198
      phase: docs
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-14T22:30:02-06:00
    - id: 160
      taskid: TASK-198
      phase: docs
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-14T22:30:02-06:00
