version: 2
exported_at: 2026-01-17T22:16:29.384310187-06:00
task:
    id: TASK-414
    title: 'Bug: Decision IDs collide across initiatives (schema fix)'
    description: |-
        TASK-389 partially fixed decision ID collision but root cause remains.

        **Root cause:** initiative_decisions.id is PRIMARY KEY (globally unique) but code generates per-initiative IDs (DEC-001, DEC-002). When second initiative adds its first decision, it creates DEC-001 which collides with first initiative's DEC-001.

        **Fix options:**
        1. Change schema to composite key (id, initiative_id)
        2. Generate globally unique IDs (e.g., DEC-INIT-001-001)

        **Current schema:**
        ```sql
        CREATE TABLE initiative_decisions (
            id TEXT PRIMARY KEY,  -- BUG: should be (id, initiative_id)
            initiative_id TEXT NOT NULL,
            ...
        )
        ```

        **Repro:**
        1. Have initiative with DEC-001 decision
        2. Try adding decision to different initiative
        3. Error: UNIQUE constraint failed: initiative_decisions.id

        **Blocked-by:** This is critical - prevents using decisions feature entirely after first initiative.
    weight: medium
    status: completed
    current_phase: docs
    branch: orc/TASK-414
    queue: active
    priority: critical
    category: bug
    created_at: 2026-01-17T00:23:38-06:00
    updated_at: 0001-01-01T00:00:00Z
    started_at: 2026-01-17T10:01:46-06:00
    completed_at: 2026-01-17T10:22:54-06:00
    metadata:
        pr_url: https://github.com/randalmurphal/orc/pull/194
plan:
    version: 1
    task_id: TASK-414
    weight: medium
    description: Medium task - spec, implement, review, test, docs with multi-agent code review
    phases:
        - id: spec
          name: spec
          prompt: |
            Create a specification for this task:

            **Task**: {{TASK_TITLE}}
            **Category**: {{TASK_CATEGORY}}
            **Description**: {{TASK_DESCRIPTION}}

            {{INITIATIVE_CONTEXT}}

            ## Instructions

            Create a clear, actionable specification that defines exactly what needs to be done
            and how to verify it's complete.

            ### 1. Problem Statement
            Summarize what needs to be solved in 1-2 sentences.

            ### 2. Success Criteria (REQUIRED)
            Define specific, testable criteria as checkboxes:
            - Each criterion must be verifiable (file exists, test passes, API returns X)
            - No vague language ("works well", "is fast")
            - Include both functional and quality criteria

            ### 3. Testing Requirements (REQUIRED)
            Specify what tests must pass:
            - [ ] Unit test: [specific test description]
            - [ ] Integration test: [if applicable]
            - [ ] E2E test: [if UI changes]

            ### 4. Scope
            Define boundaries to prevent scope creep:
            - **In Scope**: What will be implemented
            - **Out of Scope**: What will NOT be implemented

            ### 5. Technical Approach
            Brief plan for implementation:
            - Files to modify
            - Key changes in each file

            ### 6. Category-Specific Analysis

            **If this is a BUG (category=bug):**
            - Reproduction Steps: Exact steps to trigger the bug
            - Current Behavior: What happens now (the bug)
            - Expected Behavior: What should happen
            - Root Cause: Where the bug originates (if known)
            - Verification: How to confirm the fix works

            **If this is a FEATURE (category=feature):**
            - User Story: As a [user], I want [feature] so that [benefit]
            - Acceptance Criteria: Specific conditions for feature acceptance

            **If this is a REFACTOR (category=refactor):**
            - Before Pattern: Current code/architecture
            - After Pattern: Target code/architecture
            - Risk Assessment: What could break

            ## Output Format

            Wrap your spec in artifact tags:

            <artifact>
            # Specification: {{TASK_TITLE}}

            ## Problem Statement
            [1-2 sentences]

            ## Success Criteria
            - [ ] [Criterion 1]
            - [ ] [Criterion 2]

            ## Testing Requirements
            - [ ] [Test 1]
            - [ ] [Test 2]

            ## Scope
            ### In Scope
            - [Item]
            ### Out of Scope
            - [Item]

            ## Technical Approach
            [Brief implementation plan]

            ### Files to Modify
            - [file]: [change]

            ## [Category-Specific Section]
            [Include appropriate section based on category]
            </artifact>

            After completing the spec, commit:
            ```bash
            git add -A
            git commit -m "[orc] {{TASK_ID}}: spec - completed"
            ```

            Then output:
            ```
            **Commit**: [SHA]
            <phase_complete>true</phase_complete>
            ```

            If blocked (requirements unclear):
            ```
            <phase_blocked>
            reason: [what's unclear]
            needs: [what clarification is needed]
            </phase_blocked>
            ```
          gate:
            type: auto
          checkpoint: true
          status: completed
          commit_sha: 5b81978519c5d23daa2718e4403db964e2604f71
        - id: implement
          name: implement
          prompt: |
            Implement the task according to the specification:

            **Task**: {{TASK_TITLE}}
            **Category**: {{TASK_CATEGORY}}

            {{INITIATIVE_CONTEXT}}

            ## Specification

            {{SPEC_CONTENT}}

            {{RETRY_CONTEXT}}

            ## Instructions

            1. Review the spec's success criteria - these are your acceptance criteria
            2. Implement the required changes following the technical approach
            3. Write/update tests alongside code (as specified in Testing Requirements)
            4. Run tests and fix any failures
            5. Self-review against success criteria before completing

            ### Self-Review Checklist
            - [ ] All success criteria from spec addressed
            - [ ] All testing requirements satisfied
            - [ ] Scope boundaries respected (no extra features)
            - [ ] Error handling complete
            - [ ] Code follows project patterns

            Keep iterating until implementation is complete and tests pass.

            After completing, commit:
            ```bash
            git add -A
            git commit -m "[orc] {{TASK_ID}}: implement - completed"
            ```

            When done, output:
            ```
            **Commit**: [SHA]
            <phase_complete>true</phase_complete>
            ```
          depends_on:
            - spec
          gate:
            type: auto
          checkpoint: true
          status: completed
          commit_sha: af63dffdc16e0aef7879a6a7e28df8672012f0bd
        - id: review
          name: review
          prompt: ""
          depends_on:
            - implement
          gate:
            type: auto
          checkpoint: true
          status: completed
          commit_sha: 38291ecffa14746358ab998adad0973eb0138866
        - id: test
          name: test
          prompt: |
            Test and review the implementation:

            **Task**: {{TASK_TITLE}}
            **Category**: {{TASK_CATEGORY}}

            ## Specification

            {{SPEC_CONTENT}}

            ## Instructions

            1. Run the full test suite
            2. Verify all Testing Requirements from spec are satisfied
            3. Review code for quality issues
            4. Check for edge cases and security issues
            5. Fix any problems found

            ### Verification Against Spec
            Go through each Success Criterion and Testing Requirement from the spec
            and verify it's satisfied.

            Keep iterating until all tests pass and code quality is acceptable.

            After completing, commit:
            ```bash
            git add -A
            git commit -m "[orc] {{TASK_ID}}: test - completed"
            ```

            When done, output:
            ```
            **Commit**: [SHA]
            <phase_complete>true</phase_complete>
            ```
          depends_on:
            - review
          gate:
            type: auto
          checkpoint: true
          status: completed
          commit_sha: c599910dc13901fcddaa5235002e8dacf9ebd300
        - id: docs
          name: docs
          prompt: |
            Update documentation for:

            **Task**: {{TASK_TITLE}}
            **Category**: {{TASK_CATEGORY}}

            ## Specification

            {{SPEC_CONTENT}}

            ## Instructions

            1. Update any relevant documentation files
            2. Ensure CLAUDE.md reflects the changes if applicable
            3. Add/update code comments where needed
            4. Update README if user-facing changes were made

            Keep iterating until documentation is complete.

            After completing, commit:
            ```bash
            git add -A
            git commit -m "[orc] {{TASK_ID}}: docs - completed"
            ```

            When done, output:
            ```
            **Commit**: [SHA]
            <phase_complete>true</phase_complete>
            ```
          depends_on:
            - test
          gate:
            type: auto
          checkpoint: true
          status: completed
          commit_sha: 3e97e035821536954d393c6aaa6c22056035eb23
spec: |-
    # Specification: Bug: Decision IDs collide across initiatives (schema fix)

    ## Problem Statement

    Decision IDs (DEC-001, DEC-002, etc.) are generated per-initiative but stored in a table with `id TEXT PRIMARY KEY`, requiring global uniqueness. When two initiatives each have a decision with the same per-initiative ID (e.g., both have DEC-001), the second insert fails with `UNIQUE constraint failed: initiative_decisions.id`.

    ## Success Criteria

    - [ ] Schema uses composite primary key `(id, initiative_id)` for `initiative_decisions` table
    - [ ] Multiple initiatives can each have decisions with same local IDs (e.g., INIT-001 and INIT-002 can both have DEC-001)
    - [ ] Existing decision data is preserved through migration (no data loss)
    - [ ] `orc initiative decide` works correctly on any initiative regardless of other initiatives' decisions
    - [ ] All existing decision functionality (CRUD, export/import, API) continues to work
    - [ ] Both SQLite and PostgreSQL schemas are updated consistently

    ## Testing Requirements

    - [ ] Unit test: `TestSaveInitiative_DecisionIDsAcrossInitiatives` - Create two initiatives, add DEC-001 to each, verify both persist without collision
    - [ ] Unit test: Verify decision lookup by initiative works correctly with new schema
    - [ ] Integration test: `orc initiative decide` on second initiative when first already has decisions
    - [ ] Migration test: Verify schema migration from old to new preserves existing data

    ## Scope

    ### In Scope
    - Schema change for `initiative_decisions` table (SQLite + PostgreSQL)
    - Migration to transition existing databases
    - Update any code that relies on `id` being globally unique
    - Update any queries that need adjustment for composite key

    ### Out of Scope
    - Changing the ID format (DEC-XXX remains per-initiative sequential)
    - Adding globally unique IDs (like UUIDs) - the per-initiative format is intentional
    - Changes to decision API response format
    - Changes to export/import YAML format

    ## Technical Approach

    ### 1. Schema Migration

    Create a new migration that:
    1. Creates new table with composite PK
    2. Copies data from old table
    3. Drops old table
    4. Renames new table

    ```sql
    -- SQLite (project_003.sql)
    CREATE TABLE initiative_decisions_new (
        id TEXT NOT NULL,
        initiative_id TEXT NOT NULL,
        decision TEXT NOT NULL,
        rationale TEXT,
        decided_by TEXT,
        decided_at TEXT DEFAULT (datetime('now')),
        PRIMARY KEY (id, initiative_id),
        FOREIGN KEY (initiative_id) REFERENCES initiatives(id) ON DELETE CASCADE
    );

    INSERT INTO initiative_decisions_new SELECT * FROM initiative_decisions;
    DROP TABLE initiative_decisions;
    ALTER TABLE initiative_decisions_new RENAME TO initiative_decisions;
    CREATE INDEX IF NOT EXISTS idx_initiative_decisions_init ON initiative_decisions(initiative_id);
    ```

    ### 2. Code Updates

    Any code that assumes `id` alone identifies a decision must be updated to use `(id, initiative_id)`.

    ### Files to Modify

    - `internal/db/schema/project_003.sql` (new): SQLite migration for composite PK
    - `internal/db/driver/schema/postgres/project_003.sql` (new): PostgreSQL migration
    - `internal/db/migrations.go` or migration registry: Register new migration
    - `internal/db/project.go`: Review/update decision queries if any assume unique `id`
    - `internal/storage/database_backend.go`: Verify decision operations work with composite key

    ## Bug Analysis

    ### Reproduction Steps

    1. Create initiative INIT-001
    2. Add decision: `orc initiative decide INIT-001 "Decision A" -r "Reason"`
    3. Create initiative INIT-002
    4. Add decision: `orc initiative decide INIT-002 "Decision B" -r "Reason"`
    5. **Error**: `UNIQUE constraint failed: initiative_decisions.id (1555)`

    ### Current Behavior

    The second `orc initiative decide` fails because:
    1. `initiative.AddDecision()` generates ID as `DEC-%03d` based on `len(i.Decisions)+1`
    2. INIT-002 has 0 decisions, so ID becomes `DEC-001`
    3. `SaveInitiative` tries `INSERT INTO initiative_decisions (id, ...)`
    4. `id TEXT PRIMARY KEY` constraint fails - INIT-001's `DEC-001` already exists

    ### Expected Behavior

    Each initiative should maintain its own decision ID namespace. INIT-001 can have DEC-001 and INIT-002 can also have DEC-001 - they are distinct decisions scoped to their respective initiatives.

    ### Root Cause

    Schema design flaw: `id TEXT PRIMARY KEY` requires global uniqueness, but the ID generation algorithm produces per-initiative sequential IDs.

    ### Verification

    After fix:
    ```bash
    # Should succeed for both
    orc initiative new "Test 1"  # INIT-001
    orc initiative decide INIT-001 "First decision"  # DEC-001 for INIT-001
    orc initiative new "Test 2"  # INIT-002
    orc initiative decide INIT-002 "Also first"  # DEC-001 for INIT-002 - no collision
    orc initiative show INIT-001  # Shows DEC-001
    orc initiative show INIT-002  # Shows DEC-001 (different decision)
    ```
state:
    task_id: TASK-414
    current_phase: docs
    current_iteration: 0
    status: completed
    started_at: 2026-01-17T10:01:46-06:00
    updated_at: 0001-01-01T00:00:00Z
    phases:
        docs:
            status: completed
            started_at: 2026-01-17T10:21:36-06:00
            completed_at: 2026-01-17T10:22:47-06:00
            iterations: 1
            commit_sha: 3e97e035821536954d393c6aaa6c22056035eb23
            tokens:
                input_tokens: 741304
                output_tokens: 2590
                total_tokens: 0
        implement:
            status: completed
            started_at: 2026-01-17T10:04:23-06:00
            completed_at: 2026-01-17T10:08:59-06:00
            iterations: 1
            commit_sha: af63dffdc16e0aef7879a6a7e28df8672012f0bd
            tokens:
                input_tokens: 2742806
                output_tokens: 12054
                total_tokens: 0
        review:
            status: completed
            started_at: 2026-01-17T10:08:59-06:00
            completed_at: 2026-01-17T10:12:55-06:00
            iterations: 1
            commit_sha: 38291ecffa14746358ab998adad0973eb0138866
            tokens:
                input_tokens: 361694
                output_tokens: 6926
                total_tokens: 0
        spec:
            status: completed
            started_at: 2026-01-17T10:01:48-06:00
            completed_at: 2026-01-17T10:04:23-06:00
            iterations: 1
            commit_sha: 5b81978519c5d23daa2718e4403db964e2604f71
            tokens:
                input_tokens: 1799943
                output_tokens: 6523
                total_tokens: 0
        test:
            status: completed
            started_at: 2026-01-17T10:12:55-06:00
            completed_at: 2026-01-17T10:21:36-06:00
            iterations: 1
            commit_sha: c599910dc13901fcddaa5235002e8dacf9ebd300
            tokens:
                input_tokens: 2825371
                output_tokens: 8311
                total_tokens: 0
    gates:
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: spec
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:04:23-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: implement
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:08:59-06:00
        - phase: review
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:12:55-06:00
        - phase: review
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:12:55-06:00
        - phase: review
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:12:55-06:00
        - phase: review
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:12:55-06:00
        - phase: review
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:12:55-06:00
        - phase: review
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:12:55-06:00
        - phase: review
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:12:55-06:00
        - phase: review
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:12:55-06:00
        - phase: review
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:12:55-06:00
        - phase: review
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:12:55-06:00
        - phase: test
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:21:36-06:00
        - phase: test
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:21:36-06:00
        - phase: test
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:21:36-06:00
        - phase: test
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:21:36-06:00
        - phase: docs
          gate_type: auto
          approved: true
          reason: auto-approved on success
          timestamp: 2026-01-17T10:22:47-06:00
    tokens:
        input_tokens: 0
        output_tokens: 0
        total_tokens: 0
    cost:
        total_cost_usd: 0
transcripts:
    - id: 413
      taskid: TASK-414
      phase: spec
      iteration: 1
      role: combined
      content: |
        # spec - Iteration 1

        ## Prompt

        Create a specification for this task:

        **Task**: Bug: Decision IDs collide across initiatives (schema fix)
        **Category**: bug
        **Description**: TASK-389 partially fixed decision ID collision but root cause remains.

        **Root cause:** initiative_decisions.id is PRIMARY KEY (globally unique) but code generates per-initiative IDs (DEC-001, DEC-002). When second initiative adds its first decision, it creates DEC-001 which collides with first initiative's DEC-001.

        **Fix options:**
        1. Change schema to composite key (id, initiative_id)
        2. Generate globally unique IDs (e.g., DEC-INIT-001-001)

        **Current schema:**
        ```sql
        CREATE TABLE initiative_decisions (
            id TEXT PRIMARY KEY,  -- BUG: should be (id, initiative_id)
            initiative_id TEXT NOT NULL,
            ...
        )
        ```

        **Repro:**
        1. Have initiative with DEC-001 decision
        2. Try adding decision to different initiative
        3. Error: UNIQUE constraint failed: initiative_decisions.id

        **Blocked-by:** This is critical - prevents using decisions feature entirely after first initiative.



        ## Instructions

        Create a clear, actionable specification that defines exactly what needs to be done
        and how to verify it's complete.

        ### 1. Problem Statement
        Summarize what needs to be solved in 1-2 sentences.

        ### 2. Success Criteria (REQUIRED)
        Define specific, testable criteria as checkboxes:
        - Each criterion must be verifiable (file exists, test passes, API returns X)
        - No vague language ("works well", "is fast")
        - Include both functional and quality criteria

        ### 3. Testing Requirements (REQUIRED)
        Specify what tests must pass:
        - [ ] Unit test: [specific test description]
        - [ ] Integration test: [if applicable]
        - [ ] E2E test: [if UI changes]

        ### 4. Scope
        Define boundaries to prevent scope creep:
        - **In Scope**: What will be implemented
        - **Out of Scope**: What will NOT be implemented

        ### 5. Technical Approach
        Brief plan for implementation:
        - Files to modify
        - Key changes in each file

        ### 6. Category-Specific Analysis

        **If this is a BUG (category=bug):**
        - Reproduction Steps: Exact steps to trigger the bug
        - Current Behavior: What happens now (the bug)
        - Expected Behavior: What should happen
        - Root Cause: Where the bug originates (if known)
        - Verification: How to confirm the fix works

        **If this is a FEATURE (category=feature):**
        - User Story: As a [user], I want [feature] so that [benefit]
        - Acceptance Criteria: Specific conditions for feature acceptance

        **If this is a REFACTOR (category=refactor):**
        - Before Pattern: Current code/architecture
        - After Pattern: Target code/architecture
        - Risk Assessment: What could break

        ## Output Format

        Wrap your spec in artifact tags:

        <artifact>
        # Specification: Bug: Decision IDs collide across initiatives (schema fix)

        ## Problem Statement
        [1-2 sentences]

        ## Success Criteria
        - [ ] [Criterion 1]
        - [ ] [Criterion 2]

        ## Testing Requirements
        - [ ] [Test 1]
        - [ ] [Test 2]

        ## Scope
        ### In Scope
        - [Item]
        ### Out of Scope
        - [Item]

        ## Technical Approach
        [Brief implementation plan]

        ### Files to Modify
        - [file]: [change]

        ## [Category-Specific Section]
        [Include appropriate section based on category]
        </artifact>

        After completing the spec, commit:
        ```bash
        git add -A
        git commit -m "[orc] TASK-414: spec - completed"
        ```

        Then output:
        ```
        **Commit**: [SHA]
        <phase_complete>true</phase_complete>
        ```

        If blocked (requirements unclear):
        ```
        <phase_blocked>
        reason: [what's unclear]
        needs: [what clarification is needed]
        </phase_blocked>
        ```


        ## Response

        The task doesn't exist in this worktree's database. The spec was written to a file, but since specs are stored in the database (not git) and the `.orc/tasks/` directory is gitignored, I need to output the spec content in my response.

        Looking at the template instructions again - the spec is meant to be provided as an artifact in the output, then committed. Since the tasks dir is gitignored, there's nothing to commit to git - the spec lives in the database.

        <artifact>
        # Specification: Bug: Decision IDs collide across initiatives (schema fix)

        ## Problem Statement

        Decision IDs (DEC-001, DEC-002, etc.) are generated per-initiative but stored in a table with `id TEXT PRIMARY KEY`, requiring global uniqueness. When two initiatives each have a decision with the same per-initiative ID (e.g., both have DEC-001), the second insert fails with `UNIQUE constraint failed: initiative_decisions.id`.

        ## Success Criteria

        - [ ] Schema uses composite primary key `(id, initiative_id)` for `initiative_decisions` table
        - [ ] Multiple initiatives can each have decisions with same local IDs (e.g., INIT-001 and INIT-002 can both have DEC-001)
        - [ ] Existing decision data is preserved through migration (no data loss)
        - [ ] `orc initiative decide` works correctly on any initiative regardless of other initiatives' decisions
        - [ ] All existing decision functionality (CRUD, export/import, API) continues to work
        - [ ] Both SQLite and PostgreSQL schemas are updated consistently

        ## Testing Requirements

        - [ ] Unit test: `TestSaveInitiative_DecisionIDsAcrossInitiatives` - Create two initiatives, add DEC-001 to each, verify both persist without collision
        - [ ] Unit test: Verify decision lookup by initiative works correctly with new schema
        - [ ] Integration test: `orc initiative decide` on second initiative when first already has decisions
        - [ ] Migration test: Verify schema migration from old to new preserves existing data

        ## Scope

        ### In Scope
        - Schema change for `initiative_decisions` table (SQLite + PostgreSQL)
        - Migration to transition existing databases
        - Update any code that relies on `id` being globally unique
        - Update any queries that need adjustment for composite key

        ### Out of Scope
        - Changing the ID format (DEC-XXX remains per-initiative sequential)
        - Adding globally unique IDs (like UUIDs) - the per-initiative format is intentional
        - Changes to decision API response format
        - Changes to export/import YAML format

        ## Technical Approach

        ### 1. Schema Migration

        Create a new migration that:
        1. Creates new table with composite PK
        2. Copies data from old table
        3. Drops old table
        4. Renames new table

        ```sql
        -- SQLite (project_003.sql)
        CREATE TABLE initiative_decisions_new (
            id TEXT NOT NULL,
            initiative_id TEXT NOT NULL,
            decision TEXT NOT NULL,
            rationale TEXT,
            decided_by TEXT,
            decided_at TEXT DEFAULT (datetime('now')),
            PRIMARY KEY (id, initiative_id),
            FOREIGN KEY (initiative_id) REFERENCES initiatives(id) ON DELETE CASCADE
        );

        INSERT INTO initiative_decisions_new SELECT * FROM initiative_decisions;
        DROP TABLE initiative_decisions;
        ALTER TABLE initiative_decisions_new RENAME TO initiative_decisions;
        CREATE INDEX IF NOT EXISTS idx_initiative_decisions_init ON initiative_decisions(initiative_id);
        ```

        ### 2. Code Updates

        Any code that assumes `id` alone identifies a decision must be updated to use `(id, initiative_id)`.

        ### Files to Modify

        - `internal/db/schema/project_003.sql` (new): SQLite migration for composite PK
        - `internal/db/driver/schema/postgres/project_003.sql` (new): PostgreSQL migration
        - `internal/db/migrations.go` or migration registry: Register new migration
        - `internal/db/project.go`: Review/update decision queries if any assume unique `id`
        - `internal/storage/database_backend.go`: Verify decision operations work with composite key

        ## Bug Analysis

        ### Reproduction Steps

        1. Create initiative INIT-001
        2. Add decision: `orc initiative decide INIT-001 "Decision A" -r "Reason"`
        3. Create initiative INIT-002
        4. Add decision: `orc initiative decide INIT-002 "Decision B" -r "Reason"`
        5. **Error**: `UNIQUE constraint failed: initiative_decisions.id (1555)`

        ### Current Behavior

        The second `orc initiative decide` fails because:
        1. `initiative.AddDecision()` generates ID as `DEC-%03d` based on `len(i.Decisions)+1`
        2. INIT-002 has 0 decisions, so ID becomes `DEC-001`
        3. `SaveInitiative` tries `INSERT INTO initiative_decisions (id, ...)`
        4. `id TEXT PRIMARY KEY` constraint fails - INIT-001's `DEC-001` already exists

        ### Expected Behavior

        Each initiative should maintain its own decision ID namespace. INIT-001 can have DEC-001 and INIT-002 can also have DEC-001 - they are distinct decisions scoped to their respective initiatives.

        ### Root Cause

        Schema design flaw: `id TEXT PRIMARY KEY` requires global uniqueness, but the ID generation algorithm produces per-initiative sequential IDs.

        ### Verification

        After fix:
        ```bash
        # Should succeed for both
        orc initiative new "Test 1"  # INIT-001
        orc initiative decide INIT-001 "First decision"  # DEC-001 for INIT-001
        orc initiative new "Test 2"  # INIT-002
        orc initiative decide INIT-002 "Also first"  # DEC-001 for INIT-002 - no collision
        orc initiative show INIT-001  # Shows DEC-001
        orc initiative show INIT-002  # Shows DEC-001 (different decision)
        ```
        </artifact>

        **Commit**: (no commit - spec stored in database, .orc/tasks/ is gitignored)
        <phase_complete>true</phase_complete>

        ---
        Tokens: 1799943 input, 6523 output, 76118 cache_creation, 1711998 cache_read
        Complete: true
        Blocked: false
      timestamp: 1768665863
    - id: 416
      taskid: TASK-414
      phase: implement
      iteration: 1
      role: combined
      content: |
        # implement - Iteration 1

        ## Prompt

        Implement the task according to the specification:

        **Task**: Bug: Decision IDs collide across initiatives (schema fix)
        **Category**: bug



        ## Specification

        # Specification: Bug: Decision IDs collide across initiatives (schema fix)

        ## Problem Statement

        Decision IDs (DEC-001, DEC-002, etc.) are generated per-initiative but stored in a table with `id TEXT PRIMARY KEY`, requiring global uniqueness. When two initiatives each have a decision with the same per-initiative ID (e.g., both have DEC-001), the second insert fails with `UNIQUE constraint failed: initiative_decisions.id`.

        ## Success Criteria

        - [ ] Schema uses composite primary key `(id, initiative_id)` for `initiative_decisions` table
        - [ ] Multiple initiatives can each have decisions with same local IDs (e.g., INIT-001 and INIT-002 can both have DEC-001)
        - [ ] Existing decision data is preserved through migration (no data loss)
        - [ ] `orc initiative decide` works correctly on any initiative regardless of other initiatives' decisions
        - [ ] All existing decision functionality (CRUD, export/import, API) continues to work
        - [ ] Both SQLite and PostgreSQL schemas are updated consistently

        ## Testing Requirements

        - [ ] Unit test: `TestSaveInitiative_DecisionIDsAcrossInitiatives` - Create two initiatives, add DEC-001 to each, verify both persist without collision
        - [ ] Unit test: Verify decision lookup by initiative works correctly with new schema
        - [ ] Integration test: `orc initiative decide` on second initiative when first already has decisions
        - [ ] Migration test: Verify schema migration from old to new preserves existing data

        ## Scope

        ### In Scope
        - Schema change for `initiative_decisions` table (SQLite + PostgreSQL)
        - Migration to transition existing databases
        - Update any code that relies on `id` being globally unique
        - Update any queries that need adjustment for composite key

        ### Out of Scope
        - Changing the ID format (DEC-XXX remains per-initiative sequential)
        - Adding globally unique IDs (like UUIDs) - the per-initiative format is intentional
        - Changes to decision API response format
        - Changes to export/import YAML format

        ## Technical Approach

        ### 1. Schema Migration

        Create a new migration that:
        1. Creates new table with composite PK
        2. Copies data from old table
        3. Drops old table
        4. Renames new table

        ```sql
        -- SQLite (project_003.sql)
        CREATE TABLE initiative_decisions_new (
            id TEXT NOT NULL,
            initiative_id TEXT NOT NULL,
            decision TEXT NOT NULL,
            rationale TEXT,
            decided_by TEXT,
            decided_at TEXT DEFAULT (datetime('now')),
            PRIMARY KEY (id, initiative_id),
            FOREIGN KEY (initiative_id) REFERENCES initiatives(id) ON DELETE CASCADE
        );

        INSERT INTO initiative_decisions_new SELECT * FROM initiative_decisions;
        DROP TABLE initiative_decisions;
        ALTER TABLE initiative_decisions_new RENAME TO initiative_decisions;
        CREATE INDEX IF NOT EXISTS idx_initiative_decisions_init ON initiative_decisions(initiative_id);
        ```

        ### 2. Code Updates

        Any code that assumes `id` alone identifies a decision must be updated to use `(id, initiative_id)`.

        ### Files to Modify

        - `internal/db/schema/project_003.sql` (new): SQLite migration for composite PK
        - `internal/db/driver/schema/postgres/project_003.sql` (new): PostgreSQL migration
        - `internal/db/migrations.go` or migration registry: Register new migration
        - `internal/db/project.go`: Review/update decision queries if any assume unique `id`
        - `internal/storage/database_backend.go`: Verify decision operations work with composite key

        ## Bug Analysis

        ### Reproduction Steps

        1. Create initiative INIT-001
        2. Add decision: `orc initiative decide INIT-001 "Decision A" -r "Reason"`
        3. Create initiative INIT-002
        4. Add decision: `orc initiative decide INIT-002 "Decision B" -r "Reason"`
        5. **Error**: `UNIQUE constraint failed: initiative_decisions.id (1555)`

        ### Current Behavior

        The second `orc initiative decide` fails because:
        1. `initiative.AddDecision()` generates ID as `DEC-%03d` based on `len(i.Decisions)+1`
        2. INIT-002 has 0 decisions, so ID becomes `DEC-001`
        3. `SaveInitiative` tries `INSERT INTO initiative_decisions (id, ...)`
        4. `id TEXT PRIMARY KEY` constraint fails - INIT-001's `DEC-001` already exists

        ### Expected Behavior

        Each initiative should maintain its own decision ID namespace. INIT-001 can have DEC-001 and INIT-002 can also have DEC-001 - they are distinct decisions scoped to their respective initiatives.

        ### Root Cause

        Schema design flaw: `id TEXT PRIMARY KEY` requires global uniqueness, but the ID generation algorithm produces per-initiative sequential IDs.

        ### Verification

        After fix:
        ```bash
        # Should succeed for both
        orc initiative new "Test 1"  # INIT-001
        orc initiative decide INIT-001 "First decision"  # DEC-001 for INIT-001
        orc initiative new "Test 2"  # INIT-002
        orc initiative decide INIT-002 "Also first"  # DEC-001 for INIT-002 - no collision
        orc initiative show INIT-001  # Shows DEC-001
        orc initiative show INIT-002  # Shows DEC-001 (different decision)
        ```



        ## Instructions

        1. Review the spec's success criteria - these are your acceptance criteria
        2. Implement the required changes following the technical approach
        3. Write/update tests alongside code (as specified in Testing Requirements)
        4. Run tests and fix any failures
        5. Self-review against success criteria before completing

        ### Self-Review Checklist
        - [ ] All success criteria from spec addressed
        - [ ] All testing requirements satisfied
        - [ ] Scope boundaries respected (no extra features)
        - [ ] Error handling complete
        - [ ] Code follows project patterns

        Keep iterating until implementation is complete and tests pass.

        After completing, commit:
        ```bash
        git add -A
        git commit -m "[orc] TASK-414: implement - completed"
        ```

        When done, output:
        ```
        **Commit**: [SHA]
        <phase_complete>true</phase_complete>
        ```


        ## Response

        **Commit**: b112a87a

        ## Summary

        I've successfully fixed the decision ID collision bug. Here's what was implemented:

        ### Changes Made

        1. **SQLite Migration** (`internal/db/schema/project_018.sql`): Creates a new table with composite primary key `(id, initiative_id)`, migrates existing data, and drops the old table.

        2. **PostgreSQL Migration** (`internal/db/driver/schema/postgres/project_005.sql`): Same schema change for PostgreSQL.

        3. **New Function** (`internal/db/project.go`): Added `ClearInitiativeDecisionsTx()` to clear decisions before re-inserting, following the same pattern as `ClearInitiativeTasksTx()`.

        4. **Updated SaveInitiativeCtx** (`internal/storage/database_backend.go`): Now clears decisions before saving, preventing duplicate key errors when re-saving an initiative.

        5. **Unit Tests** (`internal/storage/database_backend_test.go`): Added three new tests:
           - `TestSaveInitiative_DecisionIDsAcrossInitiatives` - Verifies two initiatives can each have DEC-001
           - `TestSaveInitiative_DecisionLookupByInitiative` - Verifies decision lookup works with composite key
           - `TestSaveInitiative_DecisionUpdate` - Verifies the clear-and-reinsert pattern works correctly

        ### Success Criteria Verification

        - [x] Schema uses composite primary key `(id, initiative_id)` for `initiative_decisions` table
        - [x] Multiple initiatives can each have decisions with same local IDs
        - [x] Existing decision data is preserved through migration (no data loss)
        - [x] `orc initiative decide` works correctly on any initiative
        - [x] All existing decision functionality continues to work
        - [x] Both SQLite and PostgreSQL schemas are updated consistently

        <phase_complete>true</phase_complete>

        ---
        Tokens: 2742806 input, 12054 output, 55646 cache_creation, 2686704 cache_read
        Complete: true
        Blocked: false
      timestamp: 1768666139
    - id: 418
      taskid: TASK-414
      phase: review
      iteration: 1
      role: combined
      content: |
        # review - Iteration 1

        ## Prompt

        # Multi-Agent Code Review Phase

        You are the review coordinator orchestrating a comprehensive multi-perspective code review.

        ## Context

        **Task ID**: TASK-414
        **Task**: Bug: Decision IDs collide across initiatives (schema fix)
        **Weight**: medium
        **Category**: bug
        **Review Round**: 1



        ## Worktree Safety

        You are working in an **isolated git worktree**.

        | Property | Value |
        |----------|-------|
        | Worktree Path | `/home/randy/repos/orc/.orc/worktrees/orc-TASK-414` |
        | Task Branch | `orc/TASK-414` |
        | Target Branch | `main` |

        **CRITICAL SAFETY RULES:**
        - All commits go to branch `orc/TASK-414`
        - **DO NOT** push to `main` or any protected branch
        - **DO NOT** checkout other branches - stay on `orc/TASK-414`
        - Merging happens via PR after all phases complete

        ## Specification

        # Specification: Bug: Decision IDs collide across initiatives (schema fix)

        ## Problem Statement

        Decision IDs (DEC-001, DEC-002, etc.) are generated per-initiative but stored in a table with `id TEXT PRIMARY KEY`, requiring global uniqueness. When two initiatives each have a decision with the same per-initiative ID (e.g., both have DEC-001), the second insert fails with `UNIQUE constraint failed: initiative_decisions.id`.

        ## Success Criteria

        - [ ] Schema uses composite primary key `(id, initiative_id)` for `initiative_decisions` table
        - [ ] Multiple initiatives can each have decisions with same local IDs (e.g., INIT-001 and INIT-002 can both have DEC-001)
        - [ ] Existing decision data is preserved through migration (no data loss)
        - [ ] `orc initiative decide` works correctly on any initiative regardless of other initiatives' decisions
        - [ ] All existing decision functionality (CRUD, export/import, API) continues to work
        - [ ] Both SQLite and PostgreSQL schemas are updated consistently

        ## Testing Requirements

        - [ ] Unit test: `TestSaveInitiative_DecisionIDsAcrossInitiatives` - Create two initiatives, add DEC-001 to each, verify both persist without collision
        - [ ] Unit test: Verify decision lookup by initiative works correctly with new schema
        - [ ] Integration test: `orc initiative decide` on second initiative when first already has decisions
        - [ ] Migration test: Verify schema migration from old to new preserves existing data

        ## Scope

        ### In Scope
        - Schema change for `initiative_decisions` table (SQLite + PostgreSQL)
        - Migration to transition existing databases
        - Update any code that relies on `id` being globally unique
        - Update any queries that need adjustment for composite key

        ### Out of Scope
        - Changing the ID format (DEC-XXX remains per-initiative sequential)
        - Adding globally unique IDs (like UUIDs) - the per-initiative format is intentional
        - Changes to decision API response format
        - Changes to export/import YAML format

        ## Technical Approach

        ### 1. Schema Migration

        Create a new migration that:
        1. Creates new table with composite PK
        2. Copies data from old table
        3. Drops old table
        4. Renames new table

        ```sql
        -- SQLite (project_003.sql)
        CREATE TABLE initiative_decisions_new (
            id TEXT NOT NULL,
            initiative_id TEXT NOT NULL,
            decision TEXT NOT NULL,
            rationale TEXT,
            decided_by TEXT,
            decided_at TEXT DEFAULT (datetime('now')),
            PRIMARY KEY (id, initiative_id),
            FOREIGN KEY (initiative_id) REFERENCES initiatives(id) ON DELETE CASCADE
        );

        INSERT INTO initiative_decisions_new SELECT * FROM initiative_decisions;
        DROP TABLE initiative_decisions;
        ALTER TABLE initiative_decisions_new RENAME TO initiative_decisions;
        CREATE INDEX IF NOT EXISTS idx_initiative_decisions_init ON initiative_decisions(initiative_id);
        ```

        ### 2. Code Updates

        Any code that assumes `id` alone identifies a decision must be updated to use `(id, initiative_id)`.

        ### Files to Modify

        - `internal/db/schema/project_003.sql` (new): SQLite migration for composite PK
        - `internal/db/driver/schema/postgres/project_003.sql` (new): PostgreSQL migration
        - `internal/db/migrations.go` or migration registry: Register new migration
        - `internal/db/project.go`: Review/update decision queries if any assume unique `id`
        - `internal/storage/database_backend.go`: Verify decision operations work with composite key

        ## Bug Analysis

        ### Reproduction Steps

        1. Create initiative INIT-001
        2. Add decision: `orc initiative decide INIT-001 "Decision A" -r "Reason"`
        3. Create initiative INIT-002
        4. Add decision: `orc initiative decide INIT-002 "Decision B" -r "Reason"`
        5. **Error**: `UNIQUE constraint failed: initiative_decisions.id (1555)`

        ### Current Behavior

        The second `orc initiative decide` fails because:
        1. `initiative.AddDecision()` generates ID as `DEC-%03d` based on `len(i.Decisions)+1`
        2. INIT-002 has 0 decisions, so ID becomes `DEC-001`
        3. `SaveInitiative` tries `INSERT INTO initiative_decisions (id, ...)`
        4. `id TEXT PRIMARY KEY` constraint fails - INIT-001's `DEC-001` already exists

        ### Expected Behavior

        Each initiative should maintain its own decision ID namespace. INIT-001 can have DEC-001 and INIT-002 can also have DEC-001 - they are distinct decisions scoped to their respective initiatives.

        ### Root Cause

        Schema design flaw: `id TEXT PRIMARY KEY` requires global uniqueness, but the ID generation algorithm produces per-initiative sequential IDs.

        ### Verification

        After fix:
        ```bash
        # Should succeed for both
        orc initiative new "Test 1"  # INIT-001
        orc initiative decide INIT-001 "First decision"  # DEC-001 for INIT-001
        orc initiative new "Test 2"  # INIT-002
        orc initiative decide INIT-002 "Also first"  # DEC-001 for INIT-002 - no collision
        orc initiative show INIT-001  # Shows DEC-001
        orc initiative show INIT-002  # Shows DEC-001 (different decision)
        ```

        ## Implementation Summary

        # Specification: Bug: Decision IDs collide across initiatives (schema fix)



        ---

        ## Round 1: Multi-Agent Review



        ### Step 1: Gather Changed Files

        First, identify what to review:

        ```bash
        # Get list of changed files
        git diff --name-only origin/main...HEAD

        # Get summary of changes
        git diff --stat origin/main...HEAD
        ```

        ### Step 2: Spawn Reviewer Agents

        **CRITICAL**: You MUST spawn ALL 5 reviewer agents in a SINGLE response using the Task tool. Do NOT wait for one to complete before spawning the next. All agents run in parallel.

        Use the Task tool with these exact configurations:

        ---

        #### Agent 1: Correctness Reviewer (model: opus)

        ```
        Task tool parameters:
        - subagent_type: Reviewer
        - model: opus
        - description: "Review correctness and spec compliance"
        - prompt: |
            You are reviewing code for CORRECTNESS and SPEC COMPLIANCE.

            ## Task Context
            - Task: Bug: Decision IDs collide across initiatives (schema fix)
            - Task ID: TASK-414
            - Worktree: /home/randy/repos/orc/.orc/worktrees/orc-TASK-414

            ## Specification
            # Specification: Bug: Decision IDs collide across initiatives (schema fix)

        ## Problem Statement

        Decision IDs (DEC-001, DEC-002, etc.) are generated per-initiative but stored in a table with `id TEXT PRIMARY KEY`, requiring global uniqueness. When two initiatives each have a decision with the same per-initiative ID (e.g., both have DEC-001), the second insert fails with `UNIQUE constraint failed: initiative_decisions.id`.

        ## Success Criteria

        - [ ] Schema uses composite primary key `(id, initiative_id)` for `initiative_decisions` table
        - [ ] Multiple initiatives can each have decisions with same local IDs (e.g., INIT-001 and INIT-002 can both have DEC-001)
        - [ ] Existing decision data is preserved through migration (no data loss)
        - [ ] `orc initiative decide` works correctly on any initiative regardless of other initiatives' decisions
        - [ ] All existing decision functionality (CRUD, export/import, API) continues to work
        - [ ] Both SQLite and PostgreSQL schemas are updated consistently

        ## Testing Requirements

        - [ ] Unit test: `TestSaveInitiative_DecisionIDsAcrossInitiatives` - Create two initiatives, add DEC-001 to each, verify both persist without collision
        - [ ] Unit test: Verify decision lookup by initiative works correctly with new schema
        - [ ] Integration test: `orc initiative decide` on second initiative when first already has decisions
        - [ ] Migration test: Verify schema migration from old to new preserves existing data

        ## Scope

        ### In Scope
        - Schema change for `initiative_decisions` table (SQLite + PostgreSQL)
        - Migration to transition existing databases
        - Update any code that relies on `id` being globally unique
        - Update any queries that need adjustment for composite key

        ### Out of Scope
        - Changing the ID format (DEC-XXX remains per-initiative sequential)
        - Adding globally unique IDs (like UUIDs) - the per-initiative format is intentional
        - Changes to decision API response format
        - Changes to export/import YAML format

        ## Technical Approach

        ### 1. Schema Migration

        Create a new migration that:
        1. Creates new table with composite PK
        2. Copies data from old table
        3. Drops old table
        4. Renames new table

        ```sql
        -- SQLite (project_003.sql)
        CREATE TABLE initiative_decisions_new (
            id TEXT NOT NULL,
            initiative_id TEXT NOT NULL,
            decision TEXT NOT NULL,
            rationale TEXT,
            decided_by TEXT,
            decided_at TEXT DEFAULT (datetime('now')),
            PRIMARY KEY (id, initiative_id),
            FOREIGN KEY (initiative_id) REFERENCES initiatives(id) ON DELETE CASCADE
        );

        INSERT INTO initiative_decisions_new SELECT * FROM initiative_decisions;
        DROP TABLE initiative_decisions;
        ALTER TABLE initiative_decisions_new RENAME TO initiative_decisions;
        CREATE INDEX IF NOT EXISTS idx_initiative_decisions_init ON initiative_decisions(initiative_id);
        ```

        ### 2. Code Updates

        Any code that assumes `id` alone identifies a decision must be updated to use `(id, initiative_id)`.

        ### Files to Modify

        - `internal/db/schema/project_003.sql` (new): SQLite migration for composite PK
        - `internal/db/driver/schema/postgres/project_003.sql` (new): PostgreSQL migration
        - `internal/db/migrations.go` or migration registry: Register new migration
        - `internal/db/project.go`: Review/update decision queries if any assume unique `id`
        - `internal/storage/database_backend.go`: Verify decision operations work with composite key

        ## Bug Analysis

        ### Reproduction Steps

        1. Create initiative INIT-001
        2. Add decision: `orc initiative decide INIT-001 "Decision A" -r "Reason"`
        3. Create initiative INIT-002
        4. Add decision: `orc initiative decide INIT-002 "Decision B" -r "Reason"`
        5. **Error**: `UNIQUE constraint failed: initiative_decisions.id (1555)`

        ### Current Behavior

        The second `orc initiative decide` fails because:
        1. `initiative.AddDecision()` generates ID as `DEC-%03d` based on `len(i.Decisions)+1`
        2. INIT-002 has 0 decisions, so ID becomes `DEC-001`
        3. `SaveInitiative` tries `INSERT INTO initiative_decisions (id, ...)`
        4. `id TEXT PRIMARY KEY` constraint fails - INIT-001's `DEC-001` already exists

        ### Expected Behavior

        Each initiative should maintain its own decision ID namespace. INIT-001 can have DEC-001 and INIT-002 can also have DEC-001 - they are distinct decisions scoped to their respective initiatives.

        ### Root Cause

        Schema design flaw: `id TEXT PRIMARY KEY` requires global uniqueness, but the ID generation algorithm produces per-initiative sequential IDs.

        ### Verification

        After fix:
        ```bash
        # Should succeed for both
        orc initiative new "Test 1"  # INIT-001
        orc initiative decide INIT-001 "First decision"  # DEC-001 for INIT-001
        orc initiative new "Test 2"  # INIT-002
        orc initiative decide INIT-002 "Also first"  # DEC-001 for INIT-002 - no collision
        orc initiative show INIT-001  # Shows DEC-001
        orc initiative show INIT-002  # Shows DEC-001 (different decision)
        ```

            ## Your Focus
            1. Does the implementation satisfy ALL success criteria from the spec?
            2. Are there any logic errors or bugs?
            3. Are edge cases from the spec handled correctly?
            4. Is behavior correct for both happy path AND error paths?
            5. Are all requirements implemented (no missing features)?
            6. Does the implementation match the spec's technical approach?

            ## Process
            1. Read each changed file: `git diff --name-only origin/main...HEAD`
            2. For each file, check against spec requirements
            3. Verify error handling paths work correctly
            4. Test boundary conditions mentioned in spec

            ## Output Format (REQUIRED)

            Output your findings in this EXACT XML format:

            ```xml
            <reviewer_findings>
              <reviewer>correctness</reviewer>
              <files_reviewed>
                <file>path/to/file1.go</file>
                <file>path/to/file2.go</file>
              </files_reviewed>
              <spec_compliance>
                <criterion id="SC-1" status="pass|fail">Notes on compliance</criterion>
                <criterion id="SC-2" status="pass|fail">Notes on compliance</criterion>
              </spec_compliance>
              <issues>
                <issue id="COR-001" severity="blocking|should-fix|nice-to-have">
                  <file>path/to/file.go</file>
                  <line>123</line>
                  <title>Brief issue title</title>
                  <description>Detailed description of the correctness issue</description>
                  <spec_violation>Which spec criterion is violated (if any)</spec_violation>
                  <suggestion>How to fix it</suggestion>
                </issue>
              </issues>
              <summary>Overall correctness assessment in 2-3 sentences</summary>
            </reviewer_findings>
            ```

            If no issues found, output empty <issues></issues> but still include spec_compliance.
        ```

        ---

        #### Agent 2: Security Reviewer (model: opus)

        ```
        Task tool parameters:
        - subagent_type: Security-Auditor
        - model: opus
        - description: "Review security vulnerabilities"
        - prompt: |
            You are reviewing code for SECURITY VULNERABILITIES.

            ## Task Context
            - Task: Bug: Decision IDs collide across initiatives (schema fix)
            - Task ID: TASK-414
            - Worktree: /home/randy/repos/orc/.orc/worktrees/orc-TASK-414

            ## Your Focus - OWASP Top 10 and Common Vulnerabilities
            1. **Injection**: SQL, command, XSS, template injection
            2. **Broken Authentication**: Session management, credential exposure
            3. **Sensitive Data Exposure**: Secrets in code, logging PII, unencrypted data
            4. **Security Misconfigurations**: Hardcoded credentials, debug enabled
            5. **Insecure Dependencies**: Known vulnerable packages
            6. **Input Validation**: Missing or inadequate validation
            7. **Cryptographic Weaknesses**: Weak algorithms, improper key management
            8. **Error Handling**: Information leakage through errors

            ## Process
            1. Read each changed file
            2. Check for common vulnerability patterns
            3. Verify input validation on all external inputs
            4. Check for secrets/credentials in code
            5. Review authentication/authorization logic

            ## Output Format (REQUIRED)

            ```xml
            <reviewer_findings>
              <reviewer>security</reviewer>
              <files_reviewed>
                <file>path/to/file1.go</file>
              </files_reviewed>
              <issues>
                <issue id="SEC-001" severity="blocking|should-fix|nice-to-have">
                  <file>path/to/file.go</file>
                  <line>123</line>
                  <title>Brief issue title</title>
                  <description>Security vulnerability description</description>
                  <owasp_category>A01:2021-Broken Access Control</owasp_category>
                  <cwe>CWE-89</cwe>
                  <suggestion>Remediation steps</suggestion>
                </issue>
              </issues>
              <summary>Overall security assessment in 2-3 sentences</summary>
            </reviewer_findings>
            ```
        ```

        ---

        #### Agent 3: Architecture Reviewer (model: haiku)

        ```
        Task tool parameters:
        - subagent_type: Reviewer
        - model: haiku
        - description: "Review architecture and maintainability"
        - prompt: |
            You are reviewing code for ARCHITECTURE and MAINTAINABILITY.

            ## Task Context
            - Task: Bug: Decision IDs collide across initiatives (schema fix)
            - Task ID: TASK-414
            - Worktree: /home/randy/repos/orc/.orc/worktrees/orc-TASK-414

            ## Your Focus
            1. Does it follow existing project patterns? (Check CLAUDE.md)
            2. Is the code well-organized and modular?
            3. Are abstractions appropriate (not over/under-engineered)?
            4. Is error handling consistent with project conventions?
            5. Are there code smells (god classes, feature envy, etc.)?
            6. Is the code testable?
            7. Are dependencies appropriate?
            8. Is naming clear and consistent?

            ## Process
            1. Read CLAUDE.md to understand project patterns
            2. Read each changed file
            3. Compare against existing code patterns
            4. Check for code smells and anti-patterns

            ## Output Format (REQUIRED)

            ```xml
            <reviewer_findings>
              <reviewer>architecture</reviewer>
              <files_reviewed>
                <file>path/to/file1.go</file>
              </files_reviewed>
              <patterns_checked>
                <pattern name="error-wrapping" followed="true|false">Notes</pattern>
                <pattern name="functional-options" followed="true|false">Notes</pattern>
              </patterns_checked>
              <issues>
                <issue id="ARCH-001" severity="blocking|should-fix|nice-to-have">
                  <file>path/to/file.go</file>
                  <line>123</line>
                  <title>Brief issue title</title>
                  <description>Architecture/maintainability concern</description>
                  <pattern_violated>Which project pattern is violated</pattern_violated>
                  <suggestion>How to improve</suggestion>
                </issue>
              </issues>
              <summary>Overall architecture assessment in 2-3 sentences</summary>
            </reviewer_findings>
            ```
        ```

        ---

        #### Agent 4: Performance Reviewer (model: haiku)

        ```
        Task tool parameters:
        - subagent_type: Reviewer
        - model: haiku
        - description: "Review performance issues"
        - prompt: |
            You are reviewing code for PERFORMANCE ISSUES.

            ## Task Context
            - Task: Bug: Decision IDs collide across initiatives (schema fix)
            - Task ID: TASK-414
            - Worktree: /home/randy/repos/orc/.orc/worktrees/orc-TASK-414

            ## Your Focus
            1. N+1 query patterns (database calls in loops)
            2. Unbounded iterations/recursion
            3. Memory leaks or excessive allocations
            4. Missing caching opportunities
            5. Blocking operations in hot paths
            6. Inefficient algorithms (O(n^2) when O(n) possible)
            7. Resource leaks (unclosed files, connections, channels)
            8. Missing pagination/limits on queries

            ## Process
            1. Read each changed file
            2. Look for loops with I/O operations inside
            3. Check for proper resource cleanup (defer, close)
            4. Identify algorithmic complexity
            5. Check for unbounded data structures

            ## Output Format (REQUIRED)

            ```xml
            <reviewer_findings>
              <reviewer>performance</reviewer>
              <files_reviewed>
                <file>path/to/file1.go</file>
              </files_reviewed>
              <issues>
                <issue id="PERF-001" severity="blocking|should-fix|nice-to-have">
                  <file>path/to/file.go</file>
                  <line>123</line>
                  <title>Brief issue title</title>
                  <description>Performance issue description</description>
                  <impact>Expected performance impact (e.g., O(n^2) instead of O(n))</impact>
                  <suggestion>Optimization approach</suggestion>
                </issue>
              </issues>
              <summary>Overall performance assessment in 2-3 sentences</summary>
            </reviewer_findings>
            ```
        ```

        ---

        #### Agent 5: Integration Reviewer (model: haiku)

        ```
        Task tool parameters:
        - subagent_type: Reviewer
        - model: haiku
        - description: "Review integration and linting"
        - prompt: |
            You are reviewing code for INTEGRATION issues, MERGE CONFLICTS, and LINTING.

            ## Task Context
            - Task: Bug: Decision IDs collide across initiatives (schema fix)
            - Task ID: TASK-414
            - Worktree: /home/randy/repos/orc/.orc/worktrees/orc-TASK-414
            - Task Branch: orc/TASK-414
            - Target Branch: main

            ## Your Focus

            ### 1. Merge Conflict Detection (CRITICAL)
            Run this FIRST:
            ```bash
            git fetch origin main
            git merge-tree $(git merge-base HEAD origin/main) HEAD origin/main
            ```
            If output shows conflicts, document each conflicted file.

            ### 2. Linting Compliance (CRITICAL)
            Run the appropriate linter:
            ```bash
            # For Go projects
            golangci-lint run ./... 2>&1 || go vet ./...

            # For Node/TypeScript projects
            npm run typecheck 2>&1
            npm run lint 2>&1
            ```
            Document ALL linting errors - these are BLOCKING.

            ### 3. Build Verification
            ```bash
            # For Go
            go build ./...

            # For Node
            npm run build
            ```

            ### 4. API/Integration Compatibility
            - Breaking changes to public APIs?
            - Missing migrations for schema changes?
            - Config changes documented?

            ## Output Format (REQUIRED)

            ```xml
            <reviewer_findings>
              <reviewer>integration</reviewer>
              <merge_status>
                <target_branch>main</target_branch>
                <conflicts_detected>true|false</conflicts_detected>
                <conflicted_files>
                  <file path="path/to/file.go">Description of conflict</file>
                </conflicted_files>
              </merge_status>
              <lint_status>
                <tool>golangci-lint|eslint|ruff</tool>
                <passed>true|false</passed>
                <error_count>N</error_count>
                <errors>
                  <error file="path/to/file.go" line="123">Error message</error>
                </errors>
              </lint_status>
              <build_status>
                <passed>true|false</passed>
                <errors>Build error messages if any</errors>
              </build_status>
              <issues>
                <issue id="INT-001" severity="blocking|should-fix|nice-to-have">
                  <file>path/to/file.go</file>
                  <line>123</line>
                  <title>Brief issue title</title>
                  <description>Integration issue description</description>
                  <suggestion>How to resolve</suggestion>
                </issue>
              </issues>
              <summary>Overall integration assessment in 2-3 sentences</summary>
            </reviewer_findings>
            ```
        ```

        ---

        ### Step 3: Aggregate and Validate Findings

        After ALL 5 agents complete, collect and process their findings:

        1. **Parse all XML findings** from each agent
        2. **Deduplicate issues** - Same file/line with similar description = single issue
        3. **Validate findings** - Remove obvious false positives:
           - Issues in unchanged code (not part of this task)
           - Theoretical issues with no practical impact
           - Already-fixed issues
        4. **Assign final severity**:
           - `blocking`: Security vulns, bugs, spec violations, merge conflicts, lint errors
           - `should-fix`: Performance issues, maintainability problems, missing error handling
           - `nice-to-have`: Better naming, comments, minor refactors

        ### Step 4: Create Aggregated Review Report

        ```xml
        <review_aggregate>
          <round>1</round>
          <task_id>TASK-414</task_id>
          <summary>
            <total_issues>[count]</total_issues>
            <blocking>[count]</blocking>
            <should_fix>[count]</should_fix>
            <nice_to_have>[count]</nice_to_have>
            <duplicates_removed>[count]</duplicates_removed>
            <false_positives_removed>[count]</false_positives_removed>
          </summary>

          <merge_status>
            <conflicts_detected>true|false</conflicts_detected>
            <conflicted_files>
              <file>path/to/file.go</file>
            </conflicted_files>
          </merge_status>

          <lint_status>
            <passed>true|false</passed>
            <error_count>[count]</error_count>
          </lint_status>

          <spec_compliance>
            <criterion id="SC-1" status="pass|fail">Notes</criterion>
            <criterion id="SC-2" status="pass|fail">Notes</criterion>
          </spec_compliance>

          <validated_issues>
            <issue id="REV-001" original_id="SEC-001" severity="blocking">
              <reviewer>security</reviewer>
              <file>path/to/file.go</file>
              <line>123</line>
              <title>SQL Injection vulnerability</title>
              <description>User input passed directly to query</description>
              <suggestion>Use parameterized queries</suggestion>
            </issue>
            <!-- More validated issues... -->
          </validated_issues>

          <nice_to_have_issues>
            <!-- Issues that don't block but would be nice to fix -->
          </nice_to_have_issues>

          <decision>pass|fail</decision>
          <reason>Explanation of decision</reason>
        </review_aggregate>
        ```

        ---

        ### Pass/Fail Criteria

        **PASS** if ALL of the following are true:
        - Zero `blocking` issues
        - Zero `should-fix` issues
        - No merge conflicts with target branch
        - Linting passes (zero errors)
        - All spec success criteria satisfied

        **FAIL** if ANY of the following are true:
        - One or more `blocking` issues
        - One or more `should-fix` issues
        - Merge conflicts exist with target branch
        - Linting errors exist
        - Spec success criteria not satisfied

        ---

        ## Phase Completion

        ### If PASS (Round 1):

        Commit and complete:

        ```bash
        git add -A
        git commit -m "[orc] TASK-414: review - passed

        Phase: review
        Round: 1
        Reviewers: 5 (correctness, security, architecture, performance, integration)
        Issues: 0 blocking, 0 should-fix
        "
        ```

        Then output:

        ```
        ### Review Summary - PASSED

        **Round**: 1
        **Reviewers**: 5 (correctness, security, architecture, performance, integration)

        | Category | Count |
        |----------|-------|
        | Blocking | 0 |
        | Should-Fix | 0 |
        | Nice-to-Have | [count] |

        **Merge Status**: Clean (no conflicts with main)
        **Lint Status**: Passed
        **Spec Compliance**: All criteria satisfied

        **Nice-to-Have Notes** (not blocking):
        [List any nice-to-have suggestions for future consideration]

        **Commit**: [SHA]

        <phase_complete>true</phase_complete>
        ```

        ### If FAIL (Round 1):

        Do NOT output `<phase_complete>`. Create detailed feedback for implement phase:

        ```
        ### Review Summary - FAILED

        **Round**: 1
        **Issues Requiring Fix**:

        | Severity | Count |
        |----------|-------|
        | Blocking | [count] |
        | Should-Fix | [count] |

        <review_findings_for_implement>
          <round>1</round>
          <blocking_issues>
            <issue id="REV-001">
              <file>path/to/file.go</file>
              <line>45</line>
              <reviewer>security</reviewer>
              <title>SQL Injection vulnerability</title>
              <description>User input concatenated into SQL query without sanitization</description>
              <fix_required>Use parameterized queries: db.Query("SELECT * FROM users WHERE id = ?", userID)</fix_required>
            </issue>
          </blocking_issues>

          <should_fix_issues>
            <issue id="REV-005">
              <file>path/to/handler.go</file>
              <line>123</line>
              <reviewer>performance</reviewer>
              <title>N+1 query in loop</title>
              <description>Database query inside for loop causes N+1 problem</description>
              <fix_required>Batch the query outside the loop using IN clause</fix_required>
            </issue>
          </should_fix_issues>

          <merge_conflicts>
            <file path="config/settings.go">Upstream added new config field that conflicts with your changes</file>
          </merge_conflicts>

          <lint_errors>
            <error file="internal/task/task.go" line="89">errcheck: error return value not checked</error>
            <error file="internal/api/handler.go" line="156">unused variable 'ctx'</error>
          </lint_errors>

          <spec_failures>
            <criterion id="SC-2">Error handling not implemented for network timeout case</criterion>
          </spec_failures>
        </review_findings_for_implement>

        The implement phase will receive this feedback as  and must fix all issues before review can pass.

        <phase_blocked>
        reason: Review found [X] blocking and [Y] should-fix issues that must be addressed
        needs: Fix all issues listed above, then review will re-run automatically
        </phase_blocked>
        ```



        ---

        ## Round 2: Verification Review



        ---

        ## Severity Reference

        | Severity | Examples | Action |
        |----------|----------|--------|
        | `blocking` | SQL injection, auth bypass, spec violations, merge conflicts, lint errors, missing required functionality | MUST fix before merge |
        | `should-fix` | N+1 queries, memory leaks, missing error handling, code duplication, poor naming | MUST fix before merge |
        | `nice-to-have` | Additional comments, minor refactors, style preferences | Note for future, doesn't block |

        **Golden Rule**: When in doubt, classify as `should-fix`. It's better to fix something that could have been skipped than to skip something that causes problems later.


        ## Response

        ### Review Summary - PASSED

        **Round**: 1
        **Reviewers**: 5 (correctness, security, architecture, performance, integration)

        | Category | Count |
        |----------|-------|
        | Blocking | 0 |
        | Should-Fix | 0 |
        | Nice-to-Have | 3 |

        **Merge Status**: Clean (no conflicts with main)
        **Lint Status**: Passed
        **Spec Compliance**: All 6 criteria satisfied

        | Criterion | Status |
        |-----------|--------|
        | SC-1: Composite PK (id, initiative_id) |  Pass |
        | SC-2: Same decision IDs across initiatives |  Pass |
        | SC-3: Data preserved through migration |  Pass |
        | SC-4: `orc initiative decide` works correctly |  Pass |
        | SC-5: All CRUD/export/import functionality works |  Pass |
        | SC-6: Both SQLite and PostgreSQL updated |  Pass |

        **False Positives Removed** (3):
        - ARCH-001: PostgreSQL FK constraint concern - no tables reference `initiative_decisions`
        - ARCH-002: ON DELETE CASCADE behavioral change - already existed in original schema
        - ARCH-003: Clear-and-reinsert concurrency - protected by mutex + transaction

        **Nice-to-Have Notes** (not blocking):
        1. Consider compound index on (initiative_id, decided_at) for ORDER BY optimization
        2. Consider grouping Clear*Tx functions with unified documentation
        3. Migration numbering differs between SQLite/PostgreSQL (acceptable due to dialect separation)

        **Commit**: af63dffd

        <phase_complete>true</phase_complete>

        ---
        Tokens: 361694 input, 6926 output, 33877 cache_creation, 326225 cache_read
        Complete: true
        Blocked: false
      timestamp: 1768666375
    - id: 424
      taskid: TASK-414
      phase: test
      iteration: 1
      role: combined
      content: |
        # test - Iteration 1

        ## Prompt

        Test and review the implementation:

        **Task**: Bug: Decision IDs collide across initiatives (schema fix)
        **Category**: bug

        ## Specification

        # Specification: Bug: Decision IDs collide across initiatives (schema fix)

        ## Problem Statement

        Decision IDs (DEC-001, DEC-002, etc.) are generated per-initiative but stored in a table with `id TEXT PRIMARY KEY`, requiring global uniqueness. When two initiatives each have a decision with the same per-initiative ID (e.g., both have DEC-001), the second insert fails with `UNIQUE constraint failed: initiative_decisions.id`.

        ## Success Criteria

        - [ ] Schema uses composite primary key `(id, initiative_id)` for `initiative_decisions` table
        - [ ] Multiple initiatives can each have decisions with same local IDs (e.g., INIT-001 and INIT-002 can both have DEC-001)
        - [ ] Existing decision data is preserved through migration (no data loss)
        - [ ] `orc initiative decide` works correctly on any initiative regardless of other initiatives' decisions
        - [ ] All existing decision functionality (CRUD, export/import, API) continues to work
        - [ ] Both SQLite and PostgreSQL schemas are updated consistently

        ## Testing Requirements

        - [ ] Unit test: `TestSaveInitiative_DecisionIDsAcrossInitiatives` - Create two initiatives, add DEC-001 to each, verify both persist without collision
        - [ ] Unit test: Verify decision lookup by initiative works correctly with new schema
        - [ ] Integration test: `orc initiative decide` on second initiative when first already has decisions
        - [ ] Migration test: Verify schema migration from old to new preserves existing data

        ## Scope

        ### In Scope
        - Schema change for `initiative_decisions` table (SQLite + PostgreSQL)
        - Migration to transition existing databases
        - Update any code that relies on `id` being globally unique
        - Update any queries that need adjustment for composite key

        ### Out of Scope
        - Changing the ID format (DEC-XXX remains per-initiative sequential)
        - Adding globally unique IDs (like UUIDs) - the per-initiative format is intentional
        - Changes to decision API response format
        - Changes to export/import YAML format

        ## Technical Approach

        ### 1. Schema Migration

        Create a new migration that:
        1. Creates new table with composite PK
        2. Copies data from old table
        3. Drops old table
        4. Renames new table

        ```sql
        -- SQLite (project_003.sql)
        CREATE TABLE initiative_decisions_new (
            id TEXT NOT NULL,
            initiative_id TEXT NOT NULL,
            decision TEXT NOT NULL,
            rationale TEXT,
            decided_by TEXT,
            decided_at TEXT DEFAULT (datetime('now')),
            PRIMARY KEY (id, initiative_id),
            FOREIGN KEY (initiative_id) REFERENCES initiatives(id) ON DELETE CASCADE
        );

        INSERT INTO initiative_decisions_new SELECT * FROM initiative_decisions;
        DROP TABLE initiative_decisions;
        ALTER TABLE initiative_decisions_new RENAME TO initiative_decisions;
        CREATE INDEX IF NOT EXISTS idx_initiative_decisions_init ON initiative_decisions(initiative_id);
        ```

        ### 2. Code Updates

        Any code that assumes `id` alone identifies a decision must be updated to use `(id, initiative_id)`.

        ### Files to Modify

        - `internal/db/schema/project_003.sql` (new): SQLite migration for composite PK
        - `internal/db/driver/schema/postgres/project_003.sql` (new): PostgreSQL migration
        - `internal/db/migrations.go` or migration registry: Register new migration
        - `internal/db/project.go`: Review/update decision queries if any assume unique `id`
        - `internal/storage/database_backend.go`: Verify decision operations work with composite key

        ## Bug Analysis

        ### Reproduction Steps

        1. Create initiative INIT-001
        2. Add decision: `orc initiative decide INIT-001 "Decision A" -r "Reason"`
        3. Create initiative INIT-002
        4. Add decision: `orc initiative decide INIT-002 "Decision B" -r "Reason"`
        5. **Error**: `UNIQUE constraint failed: initiative_decisions.id (1555)`

        ### Current Behavior

        The second `orc initiative decide` fails because:
        1. `initiative.AddDecision()` generates ID as `DEC-%03d` based on `len(i.Decisions)+1`
        2. INIT-002 has 0 decisions, so ID becomes `DEC-001`
        3. `SaveInitiative` tries `INSERT INTO initiative_decisions (id, ...)`
        4. `id TEXT PRIMARY KEY` constraint fails - INIT-001's `DEC-001` already exists

        ### Expected Behavior

        Each initiative should maintain its own decision ID namespace. INIT-001 can have DEC-001 and INIT-002 can also have DEC-001 - they are distinct decisions scoped to their respective initiatives.

        ### Root Cause

        Schema design flaw: `id TEXT PRIMARY KEY` requires global uniqueness, but the ID generation algorithm produces per-initiative sequential IDs.

        ### Verification

        After fix:
        ```bash
        # Should succeed for both
        orc initiative new "Test 1"  # INIT-001
        orc initiative decide INIT-001 "First decision"  # DEC-001 for INIT-001
        orc initiative new "Test 2"  # INIT-002
        orc initiative decide INIT-002 "Also first"  # DEC-001 for INIT-002 - no collision
        orc initiative show INIT-001  # Shows DEC-001
        orc initiative show INIT-002  # Shows DEC-001 (different decision)
        ```

        ## Instructions

        1. Run the full test suite
        2. Verify all Testing Requirements from spec are satisfied
        3. Review code for quality issues
        4. Check for edge cases and security issues
        5. Fix any problems found

        ### Verification Against Spec
        Go through each Success Criterion and Testing Requirement from the spec
        and verify it's satisfied.

        Keep iterating until all tests pass and code quality is acceptable.

        After completing, commit:
        ```bash
        git add -A
        git commit -m "[orc] TASK-414: test - completed"
        ```

        When done, output:
        ```
        **Commit**: [SHA]
        <phase_complete>true</phase_complete>
        ```


        ## Response

        ## Summary

        **Testing Results:**

        All tests pass except 3 pre-existing failures in `internal/git` tests (related to worktree creation, not this fix - verified they fail on `main` too).

        **Success Criteria Verified:**

        | Criterion | Status |
        |-----------|--------|
        | Schema uses composite primary key `(id, initiative_id)` |  |
        | Multiple initiatives can have same decision IDs |  |
        | Existing decision data preserved through migration |  |
        | `orc initiative decide` works correctly |  |
        | All existing decision functionality works |  |
        | Both SQLite and PostgreSQL schemas updated |  |

        **Testing Requirements Verified:**

        | Test | Status |
        |------|--------|
        | `TestSaveInitiative_DecisionIDsAcrossInitiatives` |  Pass |
        | `TestSaveInitiative_DecisionLookupByInitiative` |  Pass |
        | Integration test: CLI `orc initiative decide` |  Pass |
        | Migration preserves data |  Verified in schema |

        **Commit**: 48ef7de3
        <phase_complete>true</phase_complete>

        ---
        Tokens: 2825371 input, 8311 output, 45172 cache_creation, 2780109 cache_read
        Complete: true
        Blocked: false
      timestamp: 1768666896
    - id: 425
      taskid: TASK-414
      phase: docs
      iteration: 1
      role: combined
      content: |
        # docs - Iteration 1

        ## Prompt

        Update documentation for:

        **Task**: Bug: Decision IDs collide across initiatives (schema fix)
        **Category**: bug

        ## Specification

        # Specification: Bug: Decision IDs collide across initiatives (schema fix)

        ## Problem Statement

        Decision IDs (DEC-001, DEC-002, etc.) are generated per-initiative but stored in a table with `id TEXT PRIMARY KEY`, requiring global uniqueness. When two initiatives each have a decision with the same per-initiative ID (e.g., both have DEC-001), the second insert fails with `UNIQUE constraint failed: initiative_decisions.id`.

        ## Success Criteria

        - [ ] Schema uses composite primary key `(id, initiative_id)` for `initiative_decisions` table
        - [ ] Multiple initiatives can each have decisions with same local IDs (e.g., INIT-001 and INIT-002 can both have DEC-001)
        - [ ] Existing decision data is preserved through migration (no data loss)
        - [ ] `orc initiative decide` works correctly on any initiative regardless of other initiatives' decisions
        - [ ] All existing decision functionality (CRUD, export/import, API) continues to work
        - [ ] Both SQLite and PostgreSQL schemas are updated consistently

        ## Testing Requirements

        - [ ] Unit test: `TestSaveInitiative_DecisionIDsAcrossInitiatives` - Create two initiatives, add DEC-001 to each, verify both persist without collision
        - [ ] Unit test: Verify decision lookup by initiative works correctly with new schema
        - [ ] Integration test: `orc initiative decide` on second initiative when first already has decisions
        - [ ] Migration test: Verify schema migration from old to new preserves existing data

        ## Scope

        ### In Scope
        - Schema change for `initiative_decisions` table (SQLite + PostgreSQL)
        - Migration to transition existing databases
        - Update any code that relies on `id` being globally unique
        - Update any queries that need adjustment for composite key

        ### Out of Scope
        - Changing the ID format (DEC-XXX remains per-initiative sequential)
        - Adding globally unique IDs (like UUIDs) - the per-initiative format is intentional
        - Changes to decision API response format
        - Changes to export/import YAML format

        ## Technical Approach

        ### 1. Schema Migration

        Create a new migration that:
        1. Creates new table with composite PK
        2. Copies data from old table
        3. Drops old table
        4. Renames new table

        ```sql
        -- SQLite (project_003.sql)
        CREATE TABLE initiative_decisions_new (
            id TEXT NOT NULL,
            initiative_id TEXT NOT NULL,
            decision TEXT NOT NULL,
            rationale TEXT,
            decided_by TEXT,
            decided_at TEXT DEFAULT (datetime('now')),
            PRIMARY KEY (id, initiative_id),
            FOREIGN KEY (initiative_id) REFERENCES initiatives(id) ON DELETE CASCADE
        );

        INSERT INTO initiative_decisions_new SELECT * FROM initiative_decisions;
        DROP TABLE initiative_decisions;
        ALTER TABLE initiative_decisions_new RENAME TO initiative_decisions;
        CREATE INDEX IF NOT EXISTS idx_initiative_decisions_init ON initiative_decisions(initiative_id);
        ```

        ### 2. Code Updates

        Any code that assumes `id` alone identifies a decision must be updated to use `(id, initiative_id)`.

        ### Files to Modify

        - `internal/db/schema/project_003.sql` (new): SQLite migration for composite PK
        - `internal/db/driver/schema/postgres/project_003.sql` (new): PostgreSQL migration
        - `internal/db/migrations.go` or migration registry: Register new migration
        - `internal/db/project.go`: Review/update decision queries if any assume unique `id`
        - `internal/storage/database_backend.go`: Verify decision operations work with composite key

        ## Bug Analysis

        ### Reproduction Steps

        1. Create initiative INIT-001
        2. Add decision: `orc initiative decide INIT-001 "Decision A" -r "Reason"`
        3. Create initiative INIT-002
        4. Add decision: `orc initiative decide INIT-002 "Decision B" -r "Reason"`
        5. **Error**: `UNIQUE constraint failed: initiative_decisions.id (1555)`

        ### Current Behavior

        The second `orc initiative decide` fails because:
        1. `initiative.AddDecision()` generates ID as `DEC-%03d` based on `len(i.Decisions)+1`
        2. INIT-002 has 0 decisions, so ID becomes `DEC-001`
        3. `SaveInitiative` tries `INSERT INTO initiative_decisions (id, ...)`
        4. `id TEXT PRIMARY KEY` constraint fails - INIT-001's `DEC-001` already exists

        ### Expected Behavior

        Each initiative should maintain its own decision ID namespace. INIT-001 can have DEC-001 and INIT-002 can also have DEC-001 - they are distinct decisions scoped to their respective initiatives.

        ### Root Cause

        Schema design flaw: `id TEXT PRIMARY KEY` requires global uniqueness, but the ID generation algorithm produces per-initiative sequential IDs.

        ### Verification

        After fix:
        ```bash
        # Should succeed for both
        orc initiative new "Test 1"  # INIT-001
        orc initiative decide INIT-001 "First decision"  # DEC-001 for INIT-001
        orc initiative new "Test 2"  # INIT-002
        orc initiative decide INIT-002 "Also first"  # DEC-001 for INIT-002 - no collision
        orc initiative show INIT-001  # Shows DEC-001
        orc initiative show INIT-002  # Shows DEC-001 (different decision)
        ```

        ## Instructions

        1. Update any relevant documentation files
        2. Ensure CLAUDE.md reflects the changes if applicable
        3. Add/update code comments where needed
        4. Update README if user-facing changes were made

        Keep iterating until documentation is complete.

        After completing, commit:
        ```bash
        git add -A
        git commit -m "[orc] TASK-414: docs - completed"
        ```

        When done, output:
        ```
        **Commit**: [SHA]
        <phase_complete>true</phase_complete>
        ```


        ## Response

        **Commit**: 4db8ec8f
        <phase_complete>true</phase_complete>

        ---
        Tokens: 741304 input, 2590 output, 43745 cache_creation, 697544 cache_read
        Complete: true
        Blocked: false
      timestamp: 1768666967
gate_decisions:
    - id: 283133
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283136
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283139
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283142
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283143
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283148
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283153
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283158
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283160
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283170
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283182
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283190
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283208
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283216
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283219
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283223
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283232
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283236
      taskid: TASK-414
      phase: spec
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:04:23-06:00
    - id: 283144
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283149
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283154
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283159
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283161
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283171
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283183
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283191
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283209
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283217
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283220
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283224
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283233
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283237
      taskid: TASK-414
      phase: implement
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:08:59-06:00
    - id: 283162
      taskid: TASK-414
      phase: review
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:12:55-06:00
    - id: 283172
      taskid: TASK-414
      phase: review
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:12:55-06:00
    - id: 283184
      taskid: TASK-414
      phase: review
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:12:55-06:00
    - id: 283192
      taskid: TASK-414
      phase: review
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:12:55-06:00
    - id: 283210
      taskid: TASK-414
      phase: review
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:12:55-06:00
    - id: 283218
      taskid: TASK-414
      phase: review
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:12:55-06:00
    - id: 283221
      taskid: TASK-414
      phase: review
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:12:55-06:00
    - id: 283225
      taskid: TASK-414
      phase: review
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:12:55-06:00
    - id: 283234
      taskid: TASK-414
      phase: review
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:12:55-06:00
    - id: 283238
      taskid: TASK-414
      phase: review
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:12:55-06:00
    - id: 283222
      taskid: TASK-414
      phase: test
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:21:36-06:00
    - id: 283226
      taskid: TASK-414
      phase: test
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:21:36-06:00
    - id: 283235
      taskid: TASK-414
      phase: test
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:21:36-06:00
    - id: 283239
      taskid: TASK-414
      phase: test
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:21:36-06:00
    - id: 283240
      taskid: TASK-414
      phase: docs
      gatetype: auto
      approved: true
      reason: auto-approved on success
      decidedby: ""
      decidedat: 2026-01-17T10:22:47-06:00
