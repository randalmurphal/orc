version: 2
exported_at: 2026-01-17T08:29:45.89326-06:00
task:
    id: TASK-397
    title: Create TimelineView page with infinite scroll
    description: "Create the main TimelineView page component at /timeline route.\n\n**ROUTE:** /timeline\n\n**PAGE LAYOUT:**\n```\n┌──────────────────────────────────────────────────────────────┐\n│ Timeline                                      [Filter ▾] \U0001F504  │\n│ Activity feed across all tasks                               │\n├──────────────────────────────────────────────────────────────┤\n│  Today  │  Yesterday  │  This Week  │  This Month  │  ⚙     │\n├──────────────────────────────────────────────────────────────┤\n│ ▼ Today (23 events)                                          │\n│ ┌────────────────────────────────────────────────────────┐   │\n│ │ ● Phase completed: implement                     2m ago│   │\n│ │   TASK-042: Add pagination to API                      │   │\n│ └────────────────────────────────────────────────────────┘   │\n│ ┌────────────────────────────────────────────────────────┐   │\n│ │ ● Task created                                   15m ago│  │\n│ │   TASK-043: Fix login timeout                          │   │\n│ └────────────────────────────────────────────────────────┘   │\n│ ... more events ...                                          │\n│                                                              │\n│ ▶ Yesterday (45 events) ─────────────────────────────────    │\n│                                                              │\n│ [Loading more...]                                            │\n└──────────────────────────────────────────────────────────────┘\n```\n\n**DATA FETCHING:**\n```typescript\n// Initial load\nconst { data, isLoading, fetchNextPage, hasNextPage } = useInfiniteQuery({\n  queryKey: ['events', timeRange, filters],\n  queryFn: ({ pageParam = 0 }) => \n    api.getEvents({ \n      since: range.since,\n      until: range.until,\n      types: filters.types,\n      limit: 50,\n      offset: pageParam \n    }),\n  getNextPageParam: (lastPage) => \n    lastPage.has_more ? lastPage.offset + lastPage.limit : undefined,\n});\n\n// Real-time updates via WebSocket\nuseWebSocket('*', (event) => {\n  queryClient.setQueryData(['events', ...], (old) => ({\n    ...old,\n    events: [eventToDisplay(event), ...old.events]\n  }));\n});\n```\n\n**FILTER DROPDOWN:**\n- Event types: checkboxes for each type\n- Tasks: search/select specific task\n- Initiatives: filter by initiative\n- Source: executor, api, cli, manual\n\n**COLLAPSIBLE GROUPS:**\n- Group events by date (Today, Yesterday, specific dates)\n- Show event count per group\n- Collapse/expand with chevron\n- Remember collapse state in localStorage\n\n**INFINITE SCROLL:**\n- Load 50 events initially\n- Fetch more when scrolled to bottom\n- Show loading indicator\n- Handle end of results gracefully\n\n**FILES TO CREATE:**\n- web/src/pages/TimelinePage.tsx\n- web/src/components/timeline/TimelineView.tsx\n- web/src/components/timeline/TimelineFilters.tsx\n- web/src/components/timeline/TimelineGroup.tsx\n- Update web/src/router/routes.tsx\n\n**SUCCESS CRITERIA:**\n1. Page loads with events from last 24h\n2. Time range selector changes query\n3. Filters work and persist in URL params\n4. Infinite scroll loads more events\n5. WebSocket updates appear at top in real-time\n6. Collapsible date groups work\n7. Empty state when no events\n8. Loading and error states handled\n\n**PERFORMANCE:**\n- Virtualize list for large event counts\n- Debounce filter changes\n- Cache API responses"
    weight: large
    status: planned
    branch: orc/TASK-397
    queue: active
    priority: normal
    category: feature
    initiative_id: INIT-024
    blocked_by:
        - TASK-394
        - TASK-395
        - TASK-396
    created_at: 2026-01-16T22:55:57-06:00
    updated_at: 0001-01-01T00:00:00Z
plan:
    version: 1
    task_id: TASK-397
    weight: large
    description: Large task - spec, design, implement, review, test, docs, validate with multi-agent code review
    phases:
        - id: spec
          name: spec
          prompt: |
            Create a specification for this large task:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            Define:
            1. Requirements and scope
            2. Technical approach
            3. Component breakdown (backend, frontend if applicable)
            4. API design (if applicable)
            5. Success criteria with explicit checkboxes
            6. Testing strategy:
               - Unit tests
               - Integration tests
               - E2E tests (using Playwright MCP tools if frontend exists)

            Include clear completion criteria:
            - What code must be written
            - What tests must pass
            - What E2E scenarios must work
            - What documentation must exist

            Keep iterating until the specification is clear and complete.

            When done, output:
            <phase_complete>true</phase_complete>
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: design
          name: design
          prompt: |
            Create architecture and design for:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            **Specification**:
            {{SPEC_CONTENT}}

            Design requirements:
            1. Define components and their responsibilities
            2. Document design decisions with rationale
            3. Assess implementation risks
            4. Define implementation order

            Output a design document with:
            - Component architecture
            - Design decisions table (DD-1, DD-2, etc.)
            - Risk assessment
            - Implementation order

            When done, output:
            <phase_complete>true</phase_complete>
          depends_on:
            - spec
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: implement
          name: implement
          prompt: |
            Implement the large task according to the specification and design:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            **Specification**:
            {{SPEC_CONTENT}}

            **Design**:
            {{DESIGN_CONTENT}}

            {{RETRY_CONTEXT}}

            Implementation protocol:
            1. Follow the design's implementation order
            2. Implement all components defined in the spec
            3. Write unit tests alongside code
            4. Run tests frequently: `go test ./... -v -race`
            5. Fix failures before continuing
            6. If frontend exists:
               - Implement all components
               - Add loading/error states
               - Integrate with API

            Keep iterating until:
            - All components implemented
            - All unit tests pass
            - No race conditions

            When done, output:
            <phase_complete>true</phase_complete>
          depends_on:
            - design
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: review
          name: review
          prompt: ""
          depends_on:
            - implement
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: test
          name: test
          prompt: |
            Comprehensive testing for:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            ## Unit Tests
            1. Run: `go test ./... -v -race -cover`
            2. Verify coverage > 80%
            3. Fix any failures

            ## Integration Tests
            1. Test component interactions
            2. Test error handling paths
            3. Verify data flows correctly

            ## E2E Tests (If frontend exists - Use Playwright MCP tools)

            Setup:
            - Start backend server
            - Start frontend server

            Test using Playwright MCP:
            1. `mcp__playwright__browser_navigate` to app URL
            2. `mcp__playwright__browser_snapshot` to verify state
            3. `mcp__playwright__browser_click` to interact
            4. `mcp__playwright__browser_type` for input
            5. `mcp__playwright__browser_wait_for` for async operations

            Critical scenarios:
            - Happy path user flow
            - Error handling
            - Edge cases

            Keep iterating until all tests pass.

            When done, output:
            <phase_complete>true</phase_complete>
          depends_on:
            - review
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: docs
          name: docs
          prompt: |
            Update documentation for:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            1. Update any relevant documentation files
            2. Ensure CLAUDE.md reflects the changes if applicable
            3. Add/update code comments where needed
            4. Update README if user-facing changes were made

            Keep iterating until documentation is complete.

            When done, output:
            <phase_complete>true</phase_complete>
          depends_on:
            - test
          gate:
            type: auto
          checkpoint: true
          status: pending
        - id: validate
          name: validate
          prompt: |
            Final validation for:

            **Task**: {{TASK_TITLE}}

            **Description**: {{TASK_DESCRIPTION}}

            ## Validation Checklist

            ### Code
            - [ ] All requirements from spec are met
            - [ ] Unit tests pass: `go test ./... -v -race`
            - [ ] Test coverage > 80%
            - [ ] No race conditions
            - [ ] Code quality acceptable (no debug statements, TODOs)

            ### Integration
            - [ ] Components work together
            - [ ] Error handling is complete
            - [ ] Performance is acceptable

            ### E2E (If frontend - MUST RUN with Playwright MCP)
            - [ ] Main user flows work
            - [ ] Error states handled
            - [ ] UI updates correctly

            ### Documentation
            - [ ] Code is documented where needed
            - [ ] CLAUDE.md updated if necessary
            - [ ] API documented if applicable

            ## Final Verification

            If frontend exists, run E2E verification:
            1. Start all servers
            2. Use Playwright MCP tools to test all features
            3. Verify everything works end-to-end

            Keep iterating until validation passes.

            When done, output:
            <phase_complete>true</phase_complete>
          depends_on:
            - docs
          gate:
            type: auto
          checkpoint: true
          status: pending
state:
    task_id: TASK-397
    current_phase: ""
    current_iteration: 0
    status: pending
    started_at: 0001-01-01T00:00:00Z
    updated_at: 0001-01-01T00:00:00Z
    phases: {}
    tokens:
        input_tokens: 0
        output_tokens: 0
        total_tokens: 0
    cost:
        total_cost_usd: 0
